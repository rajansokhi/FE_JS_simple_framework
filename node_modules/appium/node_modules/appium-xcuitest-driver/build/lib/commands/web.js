'use strict';

var _Object$assign = require('babel-runtime/core-js/object/assign')['default'];

var _regeneratorRuntime = require('babel-runtime/regenerator')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _appiumIosDriver = require('appium-ios-driver');

var _asyncbox = require('asyncbox');

var _logger = require('../logger');

var _logger2 = _interopRequireDefault(_logger);

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var extensions = {};

_Object$assign(extensions, _appiumIosDriver.iosCommands.web);

extensions.clickCoords = function callee$0$0(coords) {
  var x, y;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        x = coords.x;
        y = coords.y;
        context$1$0.next = 4;
        return _regeneratorRuntime.awrap(this.proxyCommand('/wda/tap/nil', 'POST', { x: x, y: y }));

      case 4:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

extensions.translateWebCoords = function callee$0$0(coords) {
  var webviewIndex, yOffset, webviews, wvId, rect, wvPos, realDims, cmd, _ref, w, h, wvDims, urlBarHeight, realDimensionHeight, xRatio, yRatio, newCoords;

  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    var _this = this;

    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        _logger2['default'].debug('Translating coordinates (' + JSON.stringify(coords) + ') to web coordinates');
        webviewIndex = this.webContextIndex();
        yOffset = this.opts.curOrientation === 'LANDSCAPE' ? this.landscapeWebCoordsOffset : 0;
        webviews = undefined;
        context$1$0.next = 6;
        return _regeneratorRuntime.awrap((0, _asyncbox.retryInterval)(5, 100, function callee$1$0() {
          return _regeneratorRuntime.async(function callee$1$0$(context$2$0) {
            while (1) switch (context$2$0.prev = context$2$0.next) {
              case 0:
                context$2$0.next = 2;
                return _regeneratorRuntime.awrap(this.proxyCommand('/elements', 'POST', { using: 'class name', value: 'XCUIElementTypeWebView' }));

              case 2:
                webviews = context$2$0.sent;

                if (!(!webviews || webviews.length < 1)) {
                  context$2$0.next = 5;
                  break;
                }

                throw new Error('Could not find any webviews to click inside!');

              case 5:
              case 'end':
                return context$2$0.stop();
            }
          }, null, _this);
        }));

      case 6:
        if (_lodash2['default'].isUndefined(webviews[webviewIndex])) {
          _logger2['default'].warn('Could not find webview at index ' + webviewIndex + ', taking ' + 'last available one for clicking purposes');
          webviewIndex = webviews.length - 1;
        }

        wvId = webviews[webviewIndex].ELEMENT;
        context$1$0.next = 10;
        return _regeneratorRuntime.awrap(this.proxyCommand('/element/' + wvId + '/rect', 'GET'));

      case 10:
        rect = context$1$0.sent;
        wvPos = { x: rect.x, y: rect.y };
        realDims = { w: rect.width, h: rect.height };
        cmd = '(function () { return {w: document.documentElement.clientWidth, h: document.documentElement.clientHeight}; })()';
        context$1$0.next = 16;
        return _regeneratorRuntime.awrap(this.remote.execute(cmd));

      case 16:
        _ref = context$1$0.sent;
        w = _ref.w;
        h = _ref.h;
        wvDims = { w: w, h: h };
        urlBarHeight = 64;

        wvPos.y += urlBarHeight;

        realDimensionHeight = 108;

        realDims.h -= realDimensionHeight;

        if (!(wvDims && realDims && wvPos)) {
          context$1$0.next = 30;
          break;
        }

        xRatio = realDims.w / wvDims.w;
        yRatio = realDims.h / wvDims.h;
        newCoords = {
          x: wvPos.x + Math.round(xRatio * coords.x),
          y: wvPos.y + yOffset + Math.round(yRatio * coords.y)
        };

        _logger2['default'].debug('Converted web coords ' + JSON.stringify(coords) + ' ' + ('into real coords ' + JSON.stringify(newCoords)));
        return context$1$0.abrupt('return', newCoords);

      case 30:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

extensions.checkForAlert = function callee$0$0() {
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        return context$1$0.abrupt('return', false);

      case 1:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

extensions.waitForAtom = function callee$0$0(promise) {
  var res;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        res = null;
        context$1$0.prev = 1;
        context$1$0.next = 4;
        return _regeneratorRuntime.awrap(promise);

      case 4:
        res = context$1$0.sent;
        context$1$0.next = 10;
        break;

      case 7:
        context$1$0.prev = 7;
        context$1$0.t0 = context$1$0['catch'](1);
        throw new Error('Error while executing atom: ' + context$1$0.t0.message);

      case 10:
        return context$1$0.abrupt('return', this.parseExecuteResponse(res));

      case 11:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[1, 7]]);
};

exports['default'] = extensions;
module.exports = exports['default'];

// tap on absolute coordinates

// add static offset for safari in landscape mode

// absolutize web coords

// TODO: investigate where these come from. They appear to be constants in my tests

//TODO: Add check for alert and accept/dismiss it as per autoAcceptAlert capability
//# sourceMappingURL=data:application/json;charset=utf8;base64,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OztBQUM3QixnQkFBUSxDQUFDLENBQUMsSUFBSSxtQkFBbUIsQ0FBQzs7Y0FFOUIsTUFBTSxJQUFJLFFBQVEsSUFBSSxLQUFLLENBQUE7Ozs7O0FBQ3pCLGNBQU0sR0FBRyxRQUFRLENBQUMsQ0FBQyxHQUFHLE1BQU0sQ0FBQyxDQUFDO0FBQzlCLGNBQU0sR0FBRyxRQUFRLENBQUMsQ0FBQyxHQUFHLE1BQU0sQ0FBQyxDQUFDO0FBQzlCLGlCQUFTLEdBQUc7QUFDZCxXQUFDLEVBQUUsS0FBSyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLE1BQU0sR0FBRyxNQUFNLENBQUMsQ0FBQyxDQUFDO0FBQzFDLFdBQUMsRUFBRSxLQUFLLENBQUMsQ0FBQyxHQUFHLE9BQU8sR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLE1BQU0sR0FBRyxNQUFNLENBQUMsQ0FBQyxDQUFDO1NBQ3JEOztBQUNELDRCQUFJLEtBQUssQ0FBQywwQkFBd0IsSUFBSSxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUMsZ0NBQ3hCLElBQUksQ0FBQyxTQUFTLENBQUMsU0FBUyxDQUFDLENBQUUsQ0FBQyxDQUFDOzRDQUN0RCxTQUFTOzs7Ozs7O0NBRW5CLENBQUM7O0FBRUYsVUFBVSxDQUFDLGFBQWEsR0FBRzs7Ozs0Q0FDbEIsS0FBSzs7Ozs7OztDQUNiLENBQUM7O0FBRUYsVUFBVSxDQUFDLFdBQVcsR0FBRyxvQkFBZ0IsT0FBTztNQUUxQyxHQUFHOzs7O0FBQUgsV0FBRyxHQUFHLElBQUk7Ozt5Q0FFQSxPQUFPOzs7QUFBbkIsV0FBRzs7Ozs7OztjQUVHLElBQUksS0FBSyxrQ0FBZ0MsZUFBSSxPQUFPLENBQUc7Ozs0Q0FFeEQsSUFBSSxDQUFDLG9CQUFvQixDQUFDLEdBQUcsQ0FBQzs7Ozs7OztDQUN0QyxDQUFDOztxQkFFYSxVQUFVIiwiZmlsZSI6ImxpYi9jb21tYW5kcy93ZWIuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBpb3NDb21tYW5kcyB9IGZyb20gJ2FwcGl1bS1pb3MtZHJpdmVyJztcbmltcG9ydCB7IHJldHJ5SW50ZXJ2YWwgfSBmcm9tICdhc3luY2JveCc7XG5pbXBvcnQgbG9nIGZyb20gJy4uL2xvZ2dlcic7XG5pbXBvcnQgXyBmcm9tICdsb2Rhc2gnO1xuXG5cbmxldCBleHRlbnNpb25zID0ge307XG5cbk9iamVjdC5hc3NpZ24oZXh0ZW5zaW9ucywgaW9zQ29tbWFuZHMud2ViKTtcblxuZXh0ZW5zaW9ucy5jbGlja0Nvb3JkcyA9IGFzeW5jIGZ1bmN0aW9uIChjb29yZHMpIHtcbiAgbGV0IHt4LCB5fSA9IGNvb3JkcztcblxuICAvLyB0YXAgb24gYWJzb2x1dGUgY29vcmRpbmF0ZXNcbiAgYXdhaXQgdGhpcy5wcm94eUNvbW1hbmQoJy93ZGEvdGFwL25pbCcsICdQT1NUJywge3gsIHl9KTtcbn07XG5cbmV4dGVuc2lvbnMudHJhbnNsYXRlV2ViQ29vcmRzID0gYXN5bmMgZnVuY3Rpb24gKGNvb3Jkcykge1xuICBsb2cuZGVidWcoYFRyYW5zbGF0aW5nIGNvb3JkaW5hdGVzICgke0pTT04uc3RyaW5naWZ5KGNvb3Jkcyl9KSB0byB3ZWIgY29vcmRpbmF0ZXNgKTtcbiAgbGV0IHdlYnZpZXdJbmRleCA9IHRoaXMud2ViQ29udGV4dEluZGV4KCk7XG5cbiAgLy8gYWRkIHN0YXRpYyBvZmZzZXQgZm9yIHNhZmFyaSBpbiBsYW5kc2NhcGUgbW9kZVxuICBsZXQgeU9mZnNldCA9IHRoaXMub3B0cy5jdXJPcmllbnRhdGlvbiA9PT0gJ0xBTkRTQ0FQRScgPyB0aGlzLmxhbmRzY2FwZVdlYkNvb3Jkc09mZnNldCA6IDA7XG5cbiAgLy8gYWJzb2x1dGl6ZSB3ZWIgY29vcmRzXG4gIGxldCB3ZWJ2aWV3cztcbiAgYXdhaXQgcmV0cnlJbnRlcnZhbCg1LCAxMDAsIGFzeW5jICgpID0+IHtcbiAgICB3ZWJ2aWV3cyA9IGF3YWl0IHRoaXMucHJveHlDb21tYW5kKCcvZWxlbWVudHMnLCAnUE9TVCcsIHt1c2luZzogJ2NsYXNzIG5hbWUnLCB2YWx1ZTogJ1hDVUlFbGVtZW50VHlwZVdlYlZpZXcnfSk7XG4gICAgaWYgKCF3ZWJ2aWV3cyB8fCB3ZWJ2aWV3cy5sZW5ndGggPCAxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBmaW5kIGFueSB3ZWJ2aWV3cyB0byBjbGljayBpbnNpZGUhJyk7XG4gICAgfVxuICB9KTtcbiAgaWYgKF8uaXNVbmRlZmluZWQod2Vidmlld3Nbd2Vidmlld0luZGV4XSkpIHtcbiAgICBsb2cud2FybihgQ291bGQgbm90IGZpbmQgd2VidmlldyBhdCBpbmRleCAke3dlYnZpZXdJbmRleH0sIHRha2luZyBgICtcbiAgICAgICAgICAgICAgICBgbGFzdCBhdmFpbGFibGUgb25lIGZvciBjbGlja2luZyBwdXJwb3Nlc2ApO1xuICAgIHdlYnZpZXdJbmRleCA9IHdlYnZpZXdzLmxlbmd0aCAtIDE7XG4gIH1cblxuICBsZXQgd3ZJZCA9IHdlYnZpZXdzW3dlYnZpZXdJbmRleF0uRUxFTUVOVDtcbiAgbGV0IHJlY3QgPSBhd2FpdCB0aGlzLnByb3h5Q29tbWFuZChgL2VsZW1lbnQvJHt3dklkfS9yZWN0YCwgJ0dFVCcpO1xuICBsZXQgd3ZQb3MgPSB7eDogcmVjdC54LCB5OiByZWN0Lnl9O1xuICBsZXQgcmVhbERpbXMgPSB7dzogcmVjdC53aWR0aCwgaDogcmVjdC5oZWlnaHR9O1xuXG4gIGxldCBjbWQgPSAnKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHt3OiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGgsIGg6IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHR9OyB9KSgpJztcbiAgbGV0IHt3LCBofSA9IGF3YWl0IHRoaXMucmVtb3RlLmV4ZWN1dGUoY21kKTtcbiAgbGV0IHd2RGltcyA9IHt3LCBofTtcblxuICAvLyBUT0RPOiBpbnZlc3RpZ2F0ZSB3aGVyZSB0aGVzZSBjb21lIGZyb20uIFRoZXkgYXBwZWFyIHRvIGJlIGNvbnN0YW50cyBpbiBteSB0ZXN0c1xuICBsZXQgdXJsQmFySGVpZ2h0ID0gNjQ7XG4gIHd2UG9zLnkgKz0gdXJsQmFySGVpZ2h0O1xuXG4gIGxldCByZWFsRGltZW5zaW9uSGVpZ2h0ID0gMTA4O1xuICByZWFsRGltcy5oIC09IHJlYWxEaW1lbnNpb25IZWlnaHQ7XG5cbiAgaWYgKHd2RGltcyAmJiByZWFsRGltcyAmJiB3dlBvcykge1xuICAgIGxldCB4UmF0aW8gPSByZWFsRGltcy53IC8gd3ZEaW1zLnc7XG4gICAgbGV0IHlSYXRpbyA9IHJlYWxEaW1zLmggLyB3dkRpbXMuaDtcbiAgICBsZXQgbmV3Q29vcmRzID0ge1xuICAgICAgeDogd3ZQb3MueCArIE1hdGgucm91bmQoeFJhdGlvICogY29vcmRzLngpLFxuICAgICAgeTogd3ZQb3MueSArIHlPZmZzZXQgKyBNYXRoLnJvdW5kKHlSYXRpbyAqIGNvb3Jkcy55KSxcbiAgICB9O1xuICAgIGxvZy5kZWJ1ZyhgQ29udmVydGVkIHdlYiBjb29yZHMgJHtKU09OLnN0cmluZ2lmeShjb29yZHMpfSBgICtcbiAgICAgICAgICAgICAgICBgaW50byByZWFsIGNvb3JkcyAke0pTT04uc3RyaW5naWZ5KG5ld0Nvb3Jkcyl9YCk7XG4gICAgcmV0dXJuIG5ld0Nvb3JkcztcbiAgfVxufTtcblxuZXh0ZW5zaW9ucy5jaGVja0ZvckFsZXJ0ID0gYXN5bmMgZnVuY3Rpb24gKCkge1xuICByZXR1cm4gZmFsc2U7XG59O1xuXG5leHRlbnNpb25zLndhaXRGb3JBdG9tID0gYXN5bmMgZnVuY3Rpb24gKHByb21pc2UpIHtcbiAgLy9UT0RPOiBBZGQgY2hlY2sgZm9yIGFsZXJ0IGFuZCBhY2NlcHQvZGlzbWlzcyBpdCBhcyBwZXIgYXV0b0FjY2VwdEFsZXJ0IGNhcGFiaWxpdHlcbiAgbGV0IHJlcyA9IG51bGw7XG4gIHRyeSB7XG4gICAgcmVzID0gYXdhaXQgcHJvbWlzZTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBFcnJvciB3aGlsZSBleGVjdXRpbmcgYXRvbTogJHtlcnIubWVzc2FnZX1gKTtcbiAgfVxuICByZXR1cm4gdGhpcy5wYXJzZUV4ZWN1dGVSZXNwb25zZShyZXMpO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgZXh0ZW5zaW9ucztcbiJdLCJzb3VyY2VSb290IjoiLi4vLi4vLi4ifQ==
