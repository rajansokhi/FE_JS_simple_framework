'use strict';

var _regeneratorRuntime = require('babel-runtime/regenerator')['default'];

var _getIterator = require('babel-runtime/core-js/get-iterator')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _loggerJs = require('../logger.js');

var _loggerJs2 = _interopRequireDefault(_loggerJs);

var _bluebird = require('bluebird');

var _bluebird2 = _interopRequireDefault(_bluebird);

var _appiumSupport = require('appium-support');

var _helpers = require('../helpers');

var _teen_process = require('teen_process');

var _asyncbox = require('asyncbox');

var systemCallMethods = {};

var DEFAULT_ADB_EXEC_TIMEOUT = 20000; // in milliseconds

systemCallMethods.getSdkBinaryPath = function callee$0$0(binaryName) {
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        _loggerJs2['default'].info('Checking whether ' + binaryName + ' is present');

        if (!this.sdkRoot) {
          context$1$0.next = 5;
          break;
        }

        return context$1$0.abrupt('return', this.getBinaryFromSdkRoot(binaryName));

      case 5:
        _loggerJs2['default'].warn('The ANDROID_HOME environment variable is not set to the Android SDK ' + 'root directory path. ANDROID_HOME is required for compatibility ' + ('with SDK 23+. Checking along PATH for ' + binaryName + '.'));
        context$1$0.next = 8;
        return _regeneratorRuntime.awrap(this.getBinaryFromPath(binaryName));

      case 8:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 9:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

systemCallMethods.getCommandForOS = function () {
  var cmd = "which";
  if (_appiumSupport.system.isWindows()) {
    cmd = "where";
  }
  return cmd;
};

systemCallMethods.getBinaryNameForOS = function (binaryName) {
  if (_appiumSupport.system.isWindows()) {
    if (binaryName === "android") {
      binaryName += ".bat";
    } else {
      if (binaryName.indexOf(".exe", binaryName.length - 4) === -1) {
        binaryName += ".exe";
      }
    }
  }
  return binaryName;
};

systemCallMethods.getBinaryFromSdkRoot = function callee$0$0(binaryName) {
  var binaryLoc, binaryLocs, buildToolDirs, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, versionDir, _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, loc;

  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        binaryLoc = null;

        binaryName = this.getBinaryNameForOS(binaryName);
        binaryLocs = [_path2['default'].resolve(this.sdkRoot, "platform-tools", binaryName), _path2['default'].resolve(this.sdkRoot, "tools", binaryName), _path2['default'].resolve(this.sdkRoot, "tools", "bin", binaryName)];
        buildToolDirs = [];
        context$1$0.next = 6;
        return _regeneratorRuntime.awrap((0, _helpers.getDirectories)(_path2['default'].resolve(this.sdkRoot, "build-tools")));

      case 6:
        buildToolDirs = context$1$0.sent;
        _iteratorNormalCompletion = true;
        _didIteratorError = false;
        _iteratorError = undefined;
        context$1$0.prev = 10;

        for (_iterator = _getIterator(buildToolDirs); !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          versionDir = _step.value;

          binaryLocs.push(_path2['default'].resolve(this.sdkRoot, "build-tools", versionDir, binaryName));
        }
        context$1$0.next = 18;
        break;

      case 14:
        context$1$0.prev = 14;
        context$1$0.t0 = context$1$0['catch'](10);
        _didIteratorError = true;
        _iteratorError = context$1$0.t0;

      case 18:
        context$1$0.prev = 18;
        context$1$0.prev = 19;

        if (!_iteratorNormalCompletion && _iterator['return']) {
          _iterator['return']();
        }

      case 21:
        context$1$0.prev = 21;

        if (!_didIteratorError) {
          context$1$0.next = 24;
          break;
        }

        throw _iteratorError;

      case 24:
        return context$1$0.finish(21);

      case 25:
        return context$1$0.finish(18);

      case 26:
        _iteratorNormalCompletion2 = true;
        _didIteratorError2 = false;
        _iteratorError2 = undefined;
        context$1$0.prev = 29;
        _iterator2 = _getIterator(binaryLocs);

      case 31:
        if (_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done) {
          context$1$0.next = 41;
          break;
        }

        loc = _step2.value;
        context$1$0.next = 35;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.exists(loc));

      case 35:
        if (!context$1$0.sent) {
          context$1$0.next = 38;
          break;
        }

        binaryLoc = loc;
        return context$1$0.abrupt('break', 41);

      case 38:
        _iteratorNormalCompletion2 = true;
        context$1$0.next = 31;
        break;

      case 41:
        context$1$0.next = 47;
        break;

      case 43:
        context$1$0.prev = 43;
        context$1$0.t1 = context$1$0['catch'](29);
        _didIteratorError2 = true;
        _iteratorError2 = context$1$0.t1;

      case 47:
        context$1$0.prev = 47;
        context$1$0.prev = 48;

        if (!_iteratorNormalCompletion2 && _iterator2['return']) {
          _iterator2['return']();
        }

      case 50:
        context$1$0.prev = 50;

        if (!_didIteratorError2) {
          context$1$0.next = 53;
          break;
        }

        throw _iteratorError2;

      case 53:
        return context$1$0.finish(50);

      case 54:
        return context$1$0.finish(47);

      case 55:
        if (!(binaryLoc === null)) {
          context$1$0.next = 57;
          break;
        }

        throw new Error('Could not find ' + binaryName + ' in ' + binaryLocs + ', ' + ('or supported build-tools under ' + this.sdkRoot + ' ') + 'do you have the Android SDK installed at this location?');

      case 57:
        binaryLoc = binaryLoc.trim();
        _loggerJs2['default'].info('Using ' + binaryName + ' from ' + binaryLoc);
        return context$1$0.abrupt('return', binaryLoc);

      case 60:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[10, 14, 18, 26], [19,, 21, 25], [29, 43, 47, 55], [48,, 50, 54]]);
};

systemCallMethods.getBinaryFromPath = function callee$0$0(binaryName) {
  var binaryLoc, cmd, _ref, stdout;

  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        binaryLoc = null;
        cmd = this.getCommandForOS();
        context$1$0.prev = 2;
        context$1$0.next = 5;
        return _regeneratorRuntime.awrap((0, _teen_process.exec)(cmd, [binaryName]));

      case 5:
        _ref = context$1$0.sent;
        stdout = _ref.stdout;

        _loggerJs2['default'].info('Using ' + binaryName + ' from ' + stdout);
        // TODO write a test for binaries with spaces.
        binaryLoc = stdout.trim();
        return context$1$0.abrupt('return', binaryLoc);

      case 12:
        context$1$0.prev = 12;
        context$1$0.t0 = context$1$0['catch'](2);

        _loggerJs2['default'].errorAndThrow('Could not find ' + binaryName + ' Please set the ANDROID_HOME ' + 'environment variable with the Android SDK root directory path.');

      case 15:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[2, 12]]);
};

systemCallMethods.getConnectedDevices = function callee$0$0() {
  var _ref2, stdout, startingIndex, devices, _iteratorNormalCompletion3, _didIteratorError3, _iteratorError3, _iterator3, _step3, line, lineInfo;

  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        _loggerJs2['default'].debug("Getting connected devices...");
        context$1$0.prev = 1;
        context$1$0.next = 4;
        return _regeneratorRuntime.awrap((0, _teen_process.exec)(this.executable.path, ['devices']));

      case 4:
        _ref2 = context$1$0.sent;
        stdout = _ref2.stdout;
        startingIndex = stdout.indexOf("List of devices");

        if (!(startingIndex === -1)) {
          context$1$0.next = 11;
          break;
        }

        throw new Error('Unexpected output while trying to get devices. output was: ' + stdout);

      case 11:
        // slicing ouput we care about.
        stdout = stdout.slice(startingIndex);
        devices = [];
        _iteratorNormalCompletion3 = true;
        _didIteratorError3 = false;
        _iteratorError3 = undefined;
        context$1$0.prev = 16;

        for (_iterator3 = _getIterator(stdout.split("\n")); !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          line = _step3.value;

          if (line.trim() !== "" && line.indexOf("List of devices") === -1 && line.indexOf("adb server") === -1 && line.indexOf("* daemon") === -1 && line.indexOf("offline") === -1) {
            lineInfo = line.split("\t");

            // state is either "device" or "offline", afaict
            devices.push({ udid: lineInfo[0], state: lineInfo[1] });
          }
        }
        context$1$0.next = 24;
        break;

      case 20:
        context$1$0.prev = 20;
        context$1$0.t0 = context$1$0['catch'](16);
        _didIteratorError3 = true;
        _iteratorError3 = context$1$0.t0;

      case 24:
        context$1$0.prev = 24;
        context$1$0.prev = 25;

        if (!_iteratorNormalCompletion3 && _iterator3['return']) {
          _iterator3['return']();
        }

      case 27:
        context$1$0.prev = 27;

        if (!_didIteratorError3) {
          context$1$0.next = 30;
          break;
        }

        throw _iteratorError3;

      case 30:
        return context$1$0.finish(27);

      case 31:
        return context$1$0.finish(24);

      case 32:
        _loggerJs2['default'].debug(devices.length + ' device(s) connected');
        return context$1$0.abrupt('return', devices);

      case 34:
        context$1$0.next = 39;
        break;

      case 36:
        context$1$0.prev = 36;
        context$1$0.t1 = context$1$0['catch'](1);

        _loggerJs2['default'].errorAndThrow('Error while getting connected devices. Original error: ' + context$1$0.t1.message);

      case 39:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[1, 36], [16, 20, 24, 32], [25,, 27, 31]]);
};

systemCallMethods.getDevicesWithRetry = function callee$0$0() {
  var timeoutMs = arguments.length <= 0 || arguments[0] === undefined ? 20000 : arguments[0];
  var start, getDevices;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    var _this = this;

    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        start = Date.now();

        _loggerJs2['default'].debug("Trying to find a connected android device");

        getDevices = function getDevices() {
          var devices;
          return _regeneratorRuntime.async(function getDevices$(context$2$0) {
            while (1) switch (context$2$0.prev = context$2$0.next) {
              case 0:
                if (!(Date.now() - start > timeoutMs)) {
                  context$2$0.next = 2;
                  break;
                }

                throw new Error("Could not find a connected Android device.");

              case 2:
                context$2$0.prev = 2;
                context$2$0.next = 5;
                return _regeneratorRuntime.awrap(this.getConnectedDevices());

              case 5:
                devices = context$2$0.sent;

                if (!(devices.length < 1)) {
                  context$2$0.next = 15;
                  break;
                }

                _loggerJs2['default'].debug("Could not find devices, restarting adb server...");
                context$2$0.next = 10;
                return _regeneratorRuntime.awrap(this.restartAdb());

              case 10:
                context$2$0.next = 12;
                return _regeneratorRuntime.awrap((0, _asyncbox.sleep)(200));

              case 12:
                context$2$0.next = 14;
                return _regeneratorRuntime.awrap(getDevices());

              case 14:
                return context$2$0.abrupt('return', context$2$0.sent);

              case 15:
                return context$2$0.abrupt('return', devices);

              case 18:
                context$2$0.prev = 18;
                context$2$0.t0 = context$2$0['catch'](2);

                _loggerJs2['default'].debug("Could not find devices, restarting adb server...");
                context$2$0.next = 23;
                return _regeneratorRuntime.awrap(this.restartAdb());

              case 23:
                context$2$0.next = 25;
                return _regeneratorRuntime.awrap((0, _asyncbox.sleep)(200));

              case 25:
                context$2$0.next = 27;
                return _regeneratorRuntime.awrap(getDevices());

              case 27:
                return context$2$0.abrupt('return', context$2$0.sent);

              case 28:
              case 'end':
                return context$2$0.stop();
            }
          }, null, _this, [[2, 18]]);
        };

        context$1$0.next = 5;
        return _regeneratorRuntime.awrap(getDevices());

      case 5:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 6:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

systemCallMethods.restartAdb = function callee$0$0() {
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        if (!this.suppressKillServer) {
          context$1$0.next = 3;
          break;
        }

        _loggerJs2['default'].debug('Not restarting abd since \'suppressKillServer\' is on');
        return context$1$0.abrupt('return');

      case 3:

        _loggerJs2['default'].debug('Restarting adb');
        context$1$0.prev = 4;
        context$1$0.next = 7;
        return _regeneratorRuntime.awrap((0, _teen_process.exec)(this.executable.path, ['kill-server']));

      case 7:
        context$1$0.next = 12;
        break;

      case 9:
        context$1$0.prev = 9;
        context$1$0.t0 = context$1$0['catch'](4);

        _loggerJs2['default'].error("Error killing ADB server, going to see if it's online anyway");

      case 12:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[4, 9]]);
};

systemCallMethods.adbExec = function callee$0$0(cmd) {
  var opts = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
  var execFunc;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    var _this2 = this;

    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        if (cmd) {
          context$1$0.next = 2;
          break;
        }

        throw new Error("You need to pass in a command to adbExec()");

      case 2:
        // setting default timeout for each command to prevent infinite wait.
        opts.timeout = opts.timeout || DEFAULT_ADB_EXEC_TIMEOUT;

        execFunc = function execFunc() {
          var linkerWarningRe, args, _ref3, stdout, protocolFaultError, deviceNotFoundError;

          return _regeneratorRuntime.async(function execFunc$(context$2$0) {
            while (1) switch (context$2$0.prev = context$2$0.next) {
              case 0:
                linkerWarningRe = /^WARNING: linker.+$/m;
                context$2$0.prev = 1;

                if (!(cmd instanceof Array)) {
                  cmd = [cmd];
                }
                args = this.executable.defaultArgs.concat(cmd);

                _loggerJs2['default'].debug('Running \'' + this.executable.path + '\' with args: ' + ('' + JSON.stringify(args)));
                context$2$0.next = 7;
                return _regeneratorRuntime.awrap((0, _teen_process.exec)(this.executable.path, args, opts));

              case 7:
                _ref3 = context$2$0.sent;
                stdout = _ref3.stdout;

                // sometimes ADB prints out weird stdout warnings that we don't want
                // to include in any of the response data, so let's strip it out
                stdout = stdout.replace(linkerWarningRe, '').trim();
                return context$2$0.abrupt('return', stdout);

              case 13:
                context$2$0.prev = 13;
                context$2$0.t0 = context$2$0['catch'](1);
                protocolFaultError = new RegExp("protocol fault \\(no status\\)", "i").test(context$2$0.t0);
                deviceNotFoundError = new RegExp("error: device ('.+' )?not found", "i").test(context$2$0.t0);

                if (!(protocolFaultError || deviceNotFoundError)) {
                  context$2$0.next = 23;
                  break;
                }

                _loggerJs2['default'].info('Error sending command, reconnecting device and retrying: ' + cmd);
                context$2$0.next = 21;
                return _regeneratorRuntime.awrap((0, _asyncbox.sleep)(1000));

              case 21:
                context$2$0.next = 23;
                return _regeneratorRuntime.awrap(this.getDevicesWithRetry());

              case 23:
                if (!context$2$0.t0.stdout) {
                  context$2$0.next = 27;
                  break;
                }

                stdout = context$2$0.t0.stdout;

                stdout = stdout.replace(linkerWarningRe, '').trim();
                return context$2$0.abrupt('return', stdout);

              case 27:
                throw new Error('Error executing adbExec. Original error: \'' + context$2$0.t0.message + '\'; ' + ('Stderr: \'' + (context$2$0.t0.stderr || '').trim() + '\'; Code: \'' + context$2$0.t0.code + '\''));

              case 28:
              case 'end':
                return context$2$0.stop();
            }
          }, null, _this2, [[1, 13]]);
        };

        context$1$0.next = 6;
        return _regeneratorRuntime.awrap((0, _asyncbox.retry)(2, execFunc));

      case 6:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 7:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

systemCallMethods.shell = function callee$0$0(cmd) {
  var opts = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
  var execCmd;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(this.isDeviceConnected());

      case 2:
        if (context$1$0.sent) {
          context$1$0.next = 4;
          break;
        }

        throw new Error('No device connected, cannot run adb shell command \'' + cmd.join(' ') + '\'');

      case 4:
        execCmd = ['shell'];

        if (cmd instanceof Array) {
          execCmd = execCmd.concat(cmd);
        } else {
          execCmd.push(cmd);
        }
        context$1$0.next = 8;
        return _regeneratorRuntime.awrap(this.adbExec(execCmd, opts));

      case 8:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 9:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

systemCallMethods.createSubProcess = function () {
  var args = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];

  // add the default arguments
  args = this.executable.defaultArgs.concat(args);
  _loggerJs2['default'].debug('Creating ADB subprocess with args: ' + JSON.stringify(args));
  return new _teen_process.SubProcess(this.getAdbPath(), args);
};

// TODO can probably deprecate this now that the logic is just to read
// this.adbPort
systemCallMethods.getAdbServerPort = function () {
  return this.adbPort;
};

systemCallMethods.getEmulatorPort = function callee$0$0() {
  var devices, port;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        _loggerJs2['default'].debug("Getting running emulator port");

        if (!(this.emulatorPort !== null)) {
          context$1$0.next = 3;
          break;
        }

        return context$1$0.abrupt('return', this.emulatorPort);

      case 3:
        context$1$0.prev = 3;
        context$1$0.next = 6;
        return _regeneratorRuntime.awrap(this.getConnectedDevices());

      case 6:
        devices = context$1$0.sent;
        port = this.getPortFromEmulatorString(devices[0].udid);

        if (!port) {
          context$1$0.next = 12;
          break;
        }

        return context$1$0.abrupt('return', port);

      case 12:
        throw new Error('Emulator port not found');

      case 13:
        context$1$0.next = 18;
        break;

      case 15:
        context$1$0.prev = 15;
        context$1$0.t0 = context$1$0['catch'](3);

        _loggerJs2['default'].errorAndThrow('No devices connected. Original error: ' + context$1$0.t0.message);

      case 18:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[3, 15]]);
};

systemCallMethods.getPortFromEmulatorString = function (emStr) {
  var portPattern = /emulator-(\d+)/;
  if (portPattern.test(emStr)) {
    return parseInt(portPattern.exec(emStr)[1], 10);
  }
  return false;
};

systemCallMethods.getConnectedEmulators = function callee$0$0() {
  var devices, emulators, _iteratorNormalCompletion4, _didIteratorError4, _iteratorError4, _iterator4, _step4, device, port;

  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.prev = 0;

        _loggerJs2['default'].debug("Getting connected emulators");
        context$1$0.next = 4;
        return _regeneratorRuntime.awrap(this.getConnectedDevices());

      case 4:
        devices = context$1$0.sent;
        emulators = [];
        _iteratorNormalCompletion4 = true;
        _didIteratorError4 = false;
        _iteratorError4 = undefined;
        context$1$0.prev = 9;

        for (_iterator4 = _getIterator(devices); !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
          device = _step4.value;
          port = this.getPortFromEmulatorString(device.udid);

          if (port) {
            device.port = port;
            emulators.push(device);
          }
        }
        context$1$0.next = 17;
        break;

      case 13:
        context$1$0.prev = 13;
        context$1$0.t0 = context$1$0['catch'](9);
        _didIteratorError4 = true;
        _iteratorError4 = context$1$0.t0;

      case 17:
        context$1$0.prev = 17;
        context$1$0.prev = 18;

        if (!_iteratorNormalCompletion4 && _iterator4['return']) {
          _iterator4['return']();
        }

      case 20:
        context$1$0.prev = 20;

        if (!_didIteratorError4) {
          context$1$0.next = 23;
          break;
        }

        throw _iteratorError4;

      case 23:
        return context$1$0.finish(20);

      case 24:
        return context$1$0.finish(17);

      case 25:
        _loggerJs2['default'].debug(emulators.length + ' emulator(s) connected');
        return context$1$0.abrupt('return', emulators);

      case 29:
        context$1$0.prev = 29;
        context$1$0.t1 = context$1$0['catch'](0);

        _loggerJs2['default'].errorAndThrow('Error getting emulators. Original error: ' + context$1$0.t1.message);

      case 32:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[0, 29], [9, 13, 17, 25], [18,, 20, 24]]);
};

systemCallMethods.setEmulatorPort = function (emPort) {
  this.emulatorPort = emPort;
};

systemCallMethods.setDeviceId = function (deviceId) {
  _loggerJs2['default'].debug('Setting device id to ' + deviceId);
  this.curDeviceId = deviceId;
  var argsHasDevice = this.executable.defaultArgs.indexOf('-s');
  if (argsHasDevice !== -1) {
    // remove the old device id from the arguments
    this.executable.defaultArgs.splice(argsHasDevice, 2);
  }
  this.executable.defaultArgs.push('-s', deviceId);
};

systemCallMethods.setDevice = function (deviceObj) {
  var deviceId = deviceObj.udid;
  var emPort = this.getPortFromEmulatorString(deviceId);
  this.setEmulatorPort(emPort);
  this.setDeviceId(deviceId);
};

systemCallMethods.getRunningAVD = function callee$0$0(avdName) {
  var emulators, _iteratorNormalCompletion5, _didIteratorError5, _iteratorError5, _iterator5, _step5, emulator, runningAVDName;

  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.prev = 0;

        _loggerJs2['default'].debug('Trying to find ' + avdName + ' emulator');
        context$1$0.next = 4;
        return _regeneratorRuntime.awrap(this.getConnectedEmulators());

      case 4:
        emulators = context$1$0.sent;
        _iteratorNormalCompletion5 = true;
        _didIteratorError5 = false;
        _iteratorError5 = undefined;
        context$1$0.prev = 8;
        _iterator5 = _getIterator(emulators);

      case 10:
        if (_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done) {
          context$1$0.next = 23;
          break;
        }

        emulator = _step5.value;

        this.setEmulatorPort(emulator.port);
        context$1$0.next = 15;
        return _regeneratorRuntime.awrap(this.sendTelnetCommand("avd name"));

      case 15:
        runningAVDName = context$1$0.sent;

        if (!(avdName === runningAVDName)) {
          context$1$0.next = 20;
          break;
        }

        _loggerJs2['default'].debug('Found emulator ' + avdName + ' in port ' + emulator.port);
        this.setDeviceId(emulator.udid);
        return context$1$0.abrupt('return', emulator);

      case 20:
        _iteratorNormalCompletion5 = true;
        context$1$0.next = 10;
        break;

      case 23:
        context$1$0.next = 29;
        break;

      case 25:
        context$1$0.prev = 25;
        context$1$0.t0 = context$1$0['catch'](8);
        _didIteratorError5 = true;
        _iteratorError5 = context$1$0.t0;

      case 29:
        context$1$0.prev = 29;
        context$1$0.prev = 30;

        if (!_iteratorNormalCompletion5 && _iterator5['return']) {
          _iterator5['return']();
        }

      case 32:
        context$1$0.prev = 32;

        if (!_didIteratorError5) {
          context$1$0.next = 35;
          break;
        }

        throw _iteratorError5;

      case 35:
        return context$1$0.finish(32);

      case 36:
        return context$1$0.finish(29);

      case 37:
        _loggerJs2['default'].debug('Emulator ' + avdName + ' not running');
        return context$1$0.abrupt('return', null);

      case 41:
        context$1$0.prev = 41;
        context$1$0.t1 = context$1$0['catch'](0);

        _loggerJs2['default'].errorAndThrow('Error getting AVD. Original error: ' + context$1$0.t1.message);

      case 44:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[0, 41], [8, 25, 29, 37], [30,, 32, 36]]);
};

systemCallMethods.getRunningAVDWithRetry = function callee$0$0(avdName) {
  var timeoutMs = arguments.length <= 1 || arguments[1] === undefined ? 20000 : arguments[1];
  var start, runningAVD;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.prev = 0;
        start = Date.now();

      case 2:
        if (!(Date.now() - start < timeoutMs)) {
          context$1$0.next = 18;
          break;
        }

        context$1$0.prev = 3;
        context$1$0.next = 6;
        return _regeneratorRuntime.awrap(this.getRunningAVD(avdName.replace('@', '')));

      case 6:
        runningAVD = context$1$0.sent;

        if (!runningAVD) {
          context$1$0.next = 9;
          break;
        }

        return context$1$0.abrupt('return', runningAVD);

      case 9:
        context$1$0.next = 14;
        break;

      case 11:
        context$1$0.prev = 11;
        context$1$0.t0 = context$1$0['catch'](3);

        // Do nothing.
        _loggerJs2['default'].info('Couldn\'t get running AVD, will retry. Error was: ' + context$1$0.t0.message);

      case 14:
        context$1$0.next = 16;
        return _regeneratorRuntime.awrap((0, _asyncbox.sleep)(200));

      case 16:
        context$1$0.next = 2;
        break;

      case 18:
        _loggerJs2['default'].errorAndThrow('Could not find ' + avdName + ' emulator.');
        context$1$0.next = 24;
        break;

      case 21:
        context$1$0.prev = 21;
        context$1$0.t1 = context$1$0['catch'](0);

        _loggerJs2['default'].errorAndThrow('Error getting AVD with retry. Original error: ' + context$1$0.t1.message);

      case 24:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[0, 21], [3, 11]]);
};

systemCallMethods.killAllEmulators = function callee$0$0() {
  var cmd, args;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        cmd = undefined, args = undefined;

        if (_appiumSupport.system.isWindows()) {
          cmd = 'TASKKILL';
          args = ['TASKKILL', '/IM', 'emulator.exe'];
        } else {
          cmd = '/usr/bin/killall';
          args = ['-m', 'emulator*'];
        }
        context$1$0.prev = 2;
        context$1$0.next = 5;
        return _regeneratorRuntime.awrap((0, _teen_process.exec)(cmd, args));

      case 5:
        context$1$0.next = 10;
        break;

      case 7:
        context$1$0.prev = 7;
        context$1$0.t0 = context$1$0['catch'](2);

        _loggerJs2['default'].errorAndThrow('Error killing emulators. Original error: ' + context$1$0.t0.message);

      case 10:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[2, 7]]);
};

systemCallMethods.killEmulator = function callee$0$0(avdName) {
  var device;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        _loggerJs2['default'].debug('killing avd \'' + avdName + '\'');
        context$1$0.next = 3;
        return _regeneratorRuntime.awrap(this.getRunningAVD(avdName));

      case 3:
        device = context$1$0.sent;

        if (!device) {
          context$1$0.next = 10;
          break;
        }

        context$1$0.next = 7;
        return _regeneratorRuntime.awrap(this.adbExec(['emu', 'kill']));

      case 7:
        _loggerJs2['default'].info('successfully killed emulator \'' + avdName + '\'');
        context$1$0.next = 11;
        break;

      case 10:
        _loggerJs2['default'].info('no avd with name \'' + avdName + '\' running. skipping kill step.');

      case 11:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

systemCallMethods.launchAVD = function callee$0$0(avdName, avdArgs, language, country) {
  var avdLaunchTimeout = arguments.length <= 4 || arguments[4] === undefined ? 60000 : arguments[4];
  var avdReadyTimeout = arguments.length <= 5 || arguments[5] === undefined ? 60000 : arguments[5];
  var retryTimes = arguments.length <= 6 || arguments[6] === undefined ? 1 : arguments[6];
  var emulatorBinaryPath, launchArgs, locale, proc;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        _loggerJs2['default'].debug('Launching Emulator with AVD ' + avdName + ', launchTimeout' + (avdLaunchTimeout + ' ms and readyTimeout ' + avdReadyTimeout + ' ms'));
        context$1$0.next = 3;
        return _regeneratorRuntime.awrap(this.getSdkBinaryPath("emulator"));

      case 3:
        emulatorBinaryPath = context$1$0.sent;

        if (avdName[0] === "@") {
          avdName = avdName.substr(1);
        }
        context$1$0.next = 7;
        return _regeneratorRuntime.awrap(this.checkAvdExist(avdName));

      case 7:
        launchArgs = ["-avd", avdName];

        if (typeof language === "string") {
          _loggerJs2['default'].debug('Setting Android Device Language to ' + language);
          launchArgs.push("-prop", 'persist.sys.language=' + language.toLowerCase());
        }
        if (typeof country === "string") {
          _loggerJs2['default'].debug('Setting Android Device Country to ' + country);
          launchArgs.push("-prop", 'persist.sys.country=' + country.toUpperCase());
        }
        locale = undefined;

        if (typeof language === "string" && typeof country === "string") {
          locale = language.toLowerCase() + "-" + country.toUpperCase();
        } else if (typeof language === "string") {
          locale = language.toLowerCase();
        } else if (typeof country === "string") {
          locale = country;
        }
        if (typeof locale === "string") {
          _loggerJs2['default'].debug('Setting Android Device Locale to ' + locale);
          launchArgs.push("-prop", 'persist.sys.locale=' + locale);
        }
        if (typeof avdArgs === "string") {
          avdArgs = avdArgs.split(" ");
          launchArgs = launchArgs.concat(avdArgs);
        }
        _loggerJs2['default'].debug('Running \'' + emulatorBinaryPath + '\' with args: ' + JSON.stringify(launchArgs));
        proc = new _teen_process.SubProcess(emulatorBinaryPath, launchArgs);
        context$1$0.next = 18;
        return _regeneratorRuntime.awrap(proc.start(0));

      case 18:
        proc.on('output', function (stdout, stderr) {
          _loggerJs2['default'].info('[AVD OUTPUT] ' + (stdout || stderr));
        });
        context$1$0.next = 21;
        return _regeneratorRuntime.awrap((0, _asyncbox.retry)(retryTimes, this.getRunningAVDWithRetry.bind(this), avdName, avdLaunchTimeout));

      case 21:
        context$1$0.next = 23;
        return _regeneratorRuntime.awrap(this.waitForEmulatorReady(avdReadyTimeout));

      case 23:
        return context$1$0.abrupt('return', proc);

      case 24:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

systemCallMethods.checkAvdExist = function callee$0$0(avdName) {
  var cmd, result, unknownOptionError, sdkVersion, binaryName, existings;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        cmd = undefined, result = undefined;
        context$1$0.prev = 1;
        context$1$0.next = 4;
        return _regeneratorRuntime.awrap(this.getSdkBinaryPath('emulator'));

      case 4:
        cmd = context$1$0.sent;
        context$1$0.next = 7;
        return _regeneratorRuntime.awrap((0, _teen_process.exec)(cmd, ['-list-avds']));

      case 7:
        result = context$1$0.sent;
        context$1$0.next = 25;
        break;

      case 10:
        context$1$0.prev = 10;
        context$1$0.t0 = context$1$0['catch'](1);
        unknownOptionError = new RegExp("unknown option: -list-avds", "i").test(context$1$0.t0.stderr);

        if (!unknownOptionError) {
          _loggerJs2['default'].errorAndThrow('Error executing checkAvdExist. Original error: \'' + context$1$0.t0.message + '\'; ' + ('Stderr: \'' + (context$1$0.t0.stderr || '').trim() + '\'; Code: \'' + context$1$0.t0.code + '\''));
        }
        context$1$0.next = 16;
        return _regeneratorRuntime.awrap((0, _helpers.getSdkToolsVersion)());

      case 16:
        sdkVersion = context$1$0.sent;
        binaryName = 'android';

        if (sdkVersion) {
          if (sdkVersion.major >= 25) {
            binaryName = 'avdmanager';
          }
        } else {
          _loggerJs2['default'].warn('Defaulting binary name to \'' + binaryName + '\', because SDK version cannot be parsed');
        }
        // If -list-avds option is not available, use android command as an alternative
        context$1$0.next = 21;
        return _regeneratorRuntime.awrap(this.getSdkBinaryPath(binaryName));

      case 21:
        cmd = context$1$0.sent;
        context$1$0.next = 24;
        return _regeneratorRuntime.awrap((0, _teen_process.exec)(cmd, ['list', 'avd', '-c']));

      case 24:
        result = context$1$0.sent;

      case 25:
        if (result.stdout.indexOf(avdName) === -1) {
          existings = '(' + result.stdout.trim().replace(/[\n]/g, '), (') + ')';

          _loggerJs2['default'].errorAndThrow('Avd \'' + avdName + '\' is not available. please select your avd name from one of these: \'' + existings + '\'');
        }

      case 26:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[1, 10]]);
};

systemCallMethods.waitForEmulatorReady = function callee$0$0() {
  var timeoutMs = arguments.length <= 0 || arguments[0] === undefined ? 20000 : arguments[0];
  var start, stdout;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        start = Date.now();

        _loggerJs2['default'].debug("Waiting until emulator is ready");

      case 2:
        if (!(Date.now() - start < timeoutMs)) {
          context$1$0.next = 17;
          break;
        }

        context$1$0.prev = 3;
        context$1$0.next = 6;
        return _regeneratorRuntime.awrap(this.shell(["getprop", "init.svc.bootanim"]));

      case 6:
        stdout = context$1$0.sent;

        if (!(stdout.indexOf('stopped') > -1)) {
          context$1$0.next = 9;
          break;
        }

        return context$1$0.abrupt('return');

      case 9:
        context$1$0.next = 13;
        break;

      case 11:
        context$1$0.prev = 11;
        context$1$0.t0 = context$1$0['catch'](3);

      case 13:
        context$1$0.next = 15;
        return _regeneratorRuntime.awrap((0, _asyncbox.sleep)(3000));

      case 15:
        context$1$0.next = 2;
        break;

      case 17:
        _loggerJs2['default'].errorAndThrow('Emulator not ready');

      case 18:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[3, 11]]);
};

systemCallMethods.waitForDevice = function callee$0$0() {
  var appDeviceReadyTimeout = arguments.length <= 0 || arguments[0] === undefined ? 30 : arguments[0];
  var retries, timeout;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    var _this3 = this;

    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        this.appDeviceReadyTimeout = appDeviceReadyTimeout;
        retries = 3;
        timeout = parseInt(this.appDeviceReadyTimeout, 10) / retries * 1000;
        context$1$0.next = 5;
        return _regeneratorRuntime.awrap((0, _asyncbox.retry)(retries, function callee$1$0() {
          return _regeneratorRuntime.async(function callee$1$0$(context$2$0) {
            while (1) switch (context$2$0.prev = context$2$0.next) {
              case 0:
                context$2$0.prev = 0;
                context$2$0.next = 3;
                return _regeneratorRuntime.awrap(this.adbExec('wait-for-device', { timeout: timeout }));

              case 3:
                context$2$0.next = 5;
                return _regeneratorRuntime.awrap(this.ping());

              case 5:
                context$2$0.next = 14;
                break;

              case 7:
                context$2$0.prev = 7;
                context$2$0.t0 = context$2$0['catch'](0);
                context$2$0.next = 11;
                return _regeneratorRuntime.awrap(this.restartAdb());

              case 11:
                context$2$0.next = 13;
                return _regeneratorRuntime.awrap(this.getConnectedDevices());

              case 13:
                _loggerJs2['default'].errorAndThrow('Error in waiting for device. Original error: \'' + context$2$0.t0.message + '\'. ' + 'Retrying by restarting ADB');

              case 14:
              case 'end':
                return context$2$0.stop();
            }
          }, null, _this3, [[0, 7]]);
        }));

      case 5:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

systemCallMethods.reboot = function callee$0$0() {
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    var _this4 = this;

    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.prev = 0;
        context$1$0.prev = 1;
        context$1$0.next = 4;
        return _regeneratorRuntime.awrap(this.shell(['stop']));

      case 4:
        context$1$0.next = 15;
        break;

      case 6:
        context$1$0.prev = 6;
        context$1$0.t0 = context$1$0['catch'](1);

        if (!(context$1$0.t0.message.indexOf('must be root') === -1)) {
          context$1$0.next = 10;
          break;
        }

        throw context$1$0.t0;

      case 10:
        // this device needs adb to be running as root to stop.
        // so try to restart the daemon
        _loggerJs2['default'].debug('Device requires adb to be running as root in order to reboot. Restarting daemon');
        context$1$0.next = 13;
        return _regeneratorRuntime.awrap((0, _teen_process.exec)(this.executable.path, ['root']));

      case 13:
        context$1$0.next = 15;
        return _regeneratorRuntime.awrap(this.shell(['stop']));

      case 15:
        context$1$0.next = 17;
        return _regeneratorRuntime.awrap(_bluebird2['default'].delay(2000));

      case 17:
        context$1$0.next = 19;
        return _regeneratorRuntime.awrap(this.setDeviceProperty('sys.boot_completed', 0));

      case 19:
        context$1$0.next = 21;
        return _regeneratorRuntime.awrap(this.shell(['start']));

      case 21:
        context$1$0.next = 23;
        return _regeneratorRuntime.awrap((0, _asyncbox.retryInterval)(90, 1000, function callee$1$0() {
          var booted, msg;
          return _regeneratorRuntime.async(function callee$1$0$(context$2$0) {
            while (1) switch (context$2$0.prev = context$2$0.next) {
              case 0:
                context$2$0.next = 2;
                return _regeneratorRuntime.awrap(this.getDeviceProperty('sys.boot_completed'));

              case 2:
                booted = context$2$0.sent;

                if (!(booted === '1')) {
                  context$2$0.next = 7;
                  break;
                }

                return context$2$0.abrupt('return');

              case 7:
                msg = 'Waiting for reboot. This takes time';

                _loggerJs2['default'].debug(msg);
                throw new Error(msg);

              case 10:
              case 'end':
                return context$2$0.stop();
            }
          }, null, _this4);
        }));

      case 23:
        context$1$0.prev = 23;
        context$1$0.next = 26;
        return _regeneratorRuntime.awrap((0, _teen_process.exec)(this.executable.path, ['unroot']));

      case 26:
        return context$1$0.finish(23);

      case 27:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[0,, 23, 27], [1, 6]]);
};

systemCallMethods.fileExists = function callee$0$0(remotePath) {
  var files;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(this.ls(remotePath));

      case 2:
        files = context$1$0.sent;
        return context$1$0.abrupt('return', files.length > 0);

      case 4:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

systemCallMethods.ls = function callee$0$0(remotePath) {
  var stdout, lines;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.prev = 0;
        context$1$0.next = 3;
        return _regeneratorRuntime.awrap(this.shell(['ls', remotePath]));

      case 3:
        stdout = context$1$0.sent;
        lines = stdout.split("\n");
        return context$1$0.abrupt('return', lines.map(function (l) {
          return l.trim();
        }).filter(Boolean).filter(function (l) {
          return l.indexOf("No such file") === -1;
        }));

      case 8:
        context$1$0.prev = 8;
        context$1$0.t0 = context$1$0['catch'](0);

        if (!(context$1$0.t0.message.indexOf('No such file or directory') === -1)) {
          context$1$0.next = 12;
          break;
        }

        throw context$1$0.t0;

      case 12:
        return context$1$0.abrupt('return', []);

      case 13:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[0, 8]]);
};

exports['default'] = systemCallMethods;
module.exports = exports['default'];

// get subpaths for currently installed build tool directories

// expecting adb devices to return output as
// List of devices attached
// emulator-5554	device

// cool down

// cool down

// cool down

// do nothing
// let the emu finish stopping;

// we don't want the stack trace, so no log.errorAndThrow
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYi90b29scy9zeXN0ZW0tY2FsbHMuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O29CQUFpQixNQUFNOzs7O3dCQUNQLGNBQWM7Ozs7d0JBQ2hCLFVBQVU7Ozs7NkJBQ0csZ0JBQWdCOzt1QkFDUSxZQUFZOzs0QkFDOUIsY0FBYzs7d0JBQ0gsVUFBVTs7QUFHdEQsSUFBSSxpQkFBaUIsR0FBRyxFQUFFLENBQUM7O0FBRTNCLElBQU0sd0JBQXdCLEdBQUcsS0FBSyxDQUFDOztBQUV2QyxpQkFBaUIsQ0FBQyxnQkFBZ0IsR0FBRyxvQkFBZ0IsVUFBVTs7OztBQUM3RCw4QkFBSSxJQUFJLHVCQUFxQixVQUFVLGlCQUFjLENBQUM7O2FBQ2xELElBQUksQ0FBQyxPQUFPOzs7Ozs0Q0FDUCxJQUFJLENBQUMsb0JBQW9CLENBQUMsVUFBVSxDQUFDOzs7QUFFNUMsOEJBQUksSUFBSSxDQUFDLDJJQUNrRSwrQ0FDekIsVUFBVSxPQUFHLENBQUMsQ0FBQzs7eUNBQ3BELElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxVQUFVLENBQUM7Ozs7Ozs7Ozs7Q0FHbEQsQ0FBQzs7QUFFRixpQkFBaUIsQ0FBQyxlQUFlLEdBQUcsWUFBWTtBQUM5QyxNQUFJLEdBQUcsR0FBRyxPQUFPLENBQUM7QUFDbEIsTUFBSSxzQkFBTyxTQUFTLEVBQUUsRUFBRTtBQUN0QixPQUFHLEdBQUcsT0FBTyxDQUFDO0dBQ2Y7QUFDRCxTQUFPLEdBQUcsQ0FBQztDQUNaLENBQUM7O0FBRUYsaUJBQWlCLENBQUMsa0JBQWtCLEdBQUcsVUFBVSxVQUFVLEVBQUU7QUFDM0QsTUFBSSxzQkFBTyxTQUFTLEVBQUUsRUFBRTtBQUN0QixRQUFJLFVBQVUsS0FBSyxTQUFTLEVBQUU7QUFDNUIsZ0JBQVUsSUFBSSxNQUFNLENBQUM7S0FDdEIsTUFBTTtBQUNMLFVBQUksVUFBVSxDQUFDLE9BQU8sQ0FBQyxNQUFNLEVBQUUsVUFBVSxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsS0FBSyxDQUFD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Q0FBQyxLQUFLLENBQUMsQ0FBQztTQUFBLENBQUM7Ozs7OztjQUV4RCxlQUFJLE9BQU8sQ0FBQyxPQUFPLENBQUMsMkJBQTJCLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQTs7Ozs7Ozs7NENBR3BELEVBQUU7Ozs7Ozs7Q0FFWixDQUFDOztxQkFFYSxpQkFBaUIiLCJmaWxlIjoibGliL3Rvb2xzL3N5c3RlbS1jYWxscy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBwYXRoIGZyb20gJ3BhdGgnO1xuaW1wb3J0IGxvZyBmcm9tICcuLi9sb2dnZXIuanMnO1xuaW1wb3J0IEIgZnJvbSAnYmx1ZWJpcmQnO1xuaW1wb3J0IHsgc3lzdGVtLCBmcyB9IGZyb20gJ2FwcGl1bS1zdXBwb3J0JztcbmltcG9ydCB7IGdldERpcmVjdG9yaWVzLCBnZXRTZGtUb29sc1ZlcnNpb24gfSBmcm9tICcuLi9oZWxwZXJzJztcbmltcG9ydCB7IGV4ZWMsIFN1YlByb2Nlc3MgfSBmcm9tICd0ZWVuX3Byb2Nlc3MnO1xuaW1wb3J0IHsgc2xlZXAsIHJldHJ5LCByZXRyeUludGVydmFsIH0gZnJvbSAnYXN5bmNib3gnO1xuXG5cbmxldCBzeXN0ZW1DYWxsTWV0aG9kcyA9IHt9O1xuXG5jb25zdCBERUZBVUxUX0FEQl9FWEVDX1RJTUVPVVQgPSAyMDAwMDsgLy8gaW4gbWlsbGlzZWNvbmRzXG5cbnN5c3RlbUNhbGxNZXRob2RzLmdldFNka0JpbmFyeVBhdGggPSBhc3luYyBmdW5jdGlvbiAoYmluYXJ5TmFtZSkge1xuICBsb2cuaW5mbyhgQ2hlY2tpbmcgd2hldGhlciAke2JpbmFyeU5hbWV9IGlzIHByZXNlbnRgKTtcbiAgaWYgKHRoaXMuc2RrUm9vdCkge1xuICAgIHJldHVybiB0aGlzLmdldEJpbmFyeUZyb21TZGtSb290KGJpbmFyeU5hbWUpO1xuICB9IGVsc2Uge1xuICAgIGxvZy53YXJuKGBUaGUgQU5EUk9JRF9IT01FIGVudmlyb25tZW50IHZhcmlhYmxlIGlzIG5vdCBzZXQgdG8gdGhlIEFuZHJvaWQgU0RLIGAgK1xuICAgICAgICAgICAgIGByb290IGRpcmVjdG9yeSBwYXRoLiBBTkRST0lEX0hPTUUgaXMgcmVxdWlyZWQgZm9yIGNvbXBhdGliaWxpdHkgYCArXG4gICAgICAgICAgICAgYHdpdGggU0RLIDIzKy4gQ2hlY2tpbmcgYWxvbmcgUEFUSCBmb3IgJHtiaW5hcnlOYW1lfS5gKTtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5nZXRCaW5hcnlGcm9tUGF0aChiaW5hcnlOYW1lKTtcblxuICB9XG59O1xuXG5zeXN0ZW1DYWxsTWV0aG9kcy5nZXRDb21tYW5kRm9yT1MgPSBmdW5jdGlvbiAoKSB7XG4gIGxldCBjbWQgPSBcIndoaWNoXCI7XG4gIGlmIChzeXN0ZW0uaXNXaW5kb3dzKCkpIHtcbiAgICBjbWQgPSBcIndoZXJlXCI7XG4gIH1cbiAgcmV0dXJuIGNtZDtcbn07XG5cbnN5c3RlbUNhbGxNZXRob2RzLmdldEJpbmFyeU5hbWVGb3JPUyA9IGZ1bmN0aW9uIChiaW5hcnlOYW1lKSB7XG4gIGlmIChzeXN0ZW0uaXNXaW5kb3dzKCkpIHtcbiAgICBpZiAoYmluYXJ5TmFtZSA9PT0gXCJhbmRyb2lkXCIpIHtcbiAgICAgIGJpbmFyeU5hbWUgKz0gXCIuYmF0XCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChiaW5hcnlOYW1lLmluZGV4T2YoXCIuZXhlXCIsIGJpbmFyeU5hbWUubGVuZ3RoIC0gNCkgPT09IC0xKSB7XG4gICAgICAgIGJpbmFyeU5hbWUgKz0gXCIuZXhlXCI7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBiaW5hcnlOYW1lO1xufTtcblxuc3lzdGVtQ2FsbE1ldGhvZHMuZ2V0QmluYXJ5RnJvbVNka1Jvb3QgPSBhc3luYyBmdW5jdGlvbiAoYmluYXJ5TmFtZSkge1xuICBsZXQgYmluYXJ5TG9jID0gbnVsbDtcbiAgYmluYXJ5TmFtZSA9IHRoaXMuZ2V0QmluYXJ5TmFtZUZvck9TKGJpbmFyeU5hbWUpO1xuICBsZXQgYmluYXJ5TG9jcyA9IFtwYXRoLnJlc29sdmUodGhpcy5zZGtSb290LCBcInBsYXRmb3JtLXRvb2xzXCIsIGJpbmFyeU5hbWUpLFxuICAgICAgICAgICAgICAgICAgICBwYXRoLnJlc29sdmUodGhpcy5zZGtSb290LCBcInRvb2xzXCIsIGJpbmFyeU5hbWUpLFxuICAgICAgICAgICAgICAgICAgICBwYXRoLnJlc29sdmUodGhpcy5zZGtSb290LCBcInRvb2xzXCIsIFwiYmluXCIsIGJpbmFyeU5hbWUpXTtcbiAgLy8gZ2V0IHN1YnBhdGhzIGZvciBjdXJyZW50bHkgaW5zdGFsbGVkIGJ1aWxkIHRvb2wgZGlyZWN0b3JpZXNcbiAgbGV0IGJ1aWxkVG9vbERpcnMgPSBbXTtcbiAgYnVpbGRUb29sRGlycyA9IGF3YWl0IGdldERpcmVjdG9yaWVzKHBhdGgucmVzb2x2ZSh0aGlzLnNka1Jvb3QsIFwiYnVpbGQtdG9vbHNcIikpO1xuICBmb3IgKGxldCB2ZXJzaW9uRGlyIG9mIGJ1aWxkVG9vbERpcnMpIHtcbiAgICBiaW5hcnlMb2NzLnB1c2gocGF0aC5yZXNvbHZlKHRoaXMuc2RrUm9vdCwgXCJidWlsZC10b29sc1wiLCB2ZXJzaW9uRGlyLCBiaW5hcnlOYW1lKSk7XG4gIH1cbiAgZm9yIChsZXQgbG9jIG9mIGJpbmFyeUxvY3MpIHtcbiAgICBpZiAoYXdhaXQgZnMuZXhpc3RzKGxvYykpIHtcbiAgICAgIGJpbmFyeUxvYyA9IGxvYztcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBpZiAoYmluYXJ5TG9jID09PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZCBub3QgZmluZCAke2JpbmFyeU5hbWV9IGluICR7YmluYXJ5TG9jc30sIGAgK1xuICAgICAgICAgICAgICAgICAgICBgb3Igc3VwcG9ydGVkIGJ1aWxkLXRvb2xzIHVuZGVyICR7dGhpcy5zZGtSb290fSBgICtcbiAgICAgICAgICAgICAgICAgICAgYGRvIHlvdSBoYXZlIHRoZSBBbmRyb2lkIFNESyBpbnN0YWxsZWQgYXQgdGhpcyBsb2NhdGlvbj9gKTtcbiAgfVxuICBiaW5hcnlMb2MgPSBiaW5hcnlMb2MudHJpbSgpO1xuICBsb2cuaW5mbyhgVXNpbmcgJHtiaW5hcnlOYW1lfSBmcm9tICR7YmluYXJ5TG9jfWApO1xuICByZXR1cm4gYmluYXJ5TG9jO1xufTtcblxuc3lzdGVtQ2FsbE1ldGhvZHMuZ2V0QmluYXJ5RnJvbVBhdGggPSBhc3luYyBmdW5jdGlvbiAoYmluYXJ5TmFtZSkge1xuICBsZXQgYmluYXJ5TG9jID0gbnVsbDtcbiAgbGV0IGNtZCA9IHRoaXMuZ2V0Q29tbWFuZEZvck9TKCk7XG4gIHRyeSB7XG4gICAgbGV0IHtzdGRvdXR9ID0gYXdhaXQgZXhlYyhjbWQsIFtiaW5hcnlOYW1lXSk7XG4gICAgbG9nLmluZm8oYFVzaW5nICR7YmluYXJ5TmFtZX0gZnJvbSAke3N0ZG91dH1gKTtcbiAgICAvLyBUT0RPIHdyaXRlIGEgdGVzdCBmb3IgYmluYXJpZXMgd2l0aCBzcGFjZXMuXG4gICAgYmluYXJ5TG9jID0gc3Rkb3V0LnRyaW0oKTtcbiAgICByZXR1cm4gYmluYXJ5TG9jO1xuICB9IGNhdGNoIChlKSB7XG4gICAgbG9nLmVycm9yQW5kVGhyb3coYENvdWxkIG5vdCBmaW5kICR7YmluYXJ5TmFtZX0gUGxlYXNlIHNldCB0aGUgQU5EUk9JRF9IT01FIGAgK1xuICAgICAgICAgICAgICBgZW52aXJvbm1lbnQgdmFyaWFibGUgd2l0aCB0aGUgQW5kcm9pZCBTREsgcm9vdCBkaXJlY3RvcnkgcGF0aC5gKTtcbiAgfVxufTtcblxuc3lzdGVtQ2FsbE1ldGhvZHMuZ2V0Q29ubmVjdGVkRGV2aWNlcyA9IGFzeW5jIGZ1bmN0aW9uICgpIHtcbiAgbG9nLmRlYnVnKFwiR2V0dGluZyBjb25uZWN0ZWQgZGV2aWNlcy4uLlwiKTtcbiAgdHJ5IHtcbiAgICBsZXQge3N0ZG91dH0gPSBhd2FpdCBleGVjKHRoaXMuZXhlY3V0YWJsZS5wYXRoLCBbJ2RldmljZXMnXSk7XG4gICAgLy8gZXhwZWN0aW5nIGFkYiBkZXZpY2VzIHRvIHJldHVybiBvdXRwdXQgYXNcbiAgICAvLyBMaXN0IG9mIGRldmljZXMgYXR0YWNoZWRcbiAgICAvLyBlbXVsYXRvci01NTU0XHRkZXZpY2VcbiAgICBsZXQgc3RhcnRpbmdJbmRleCA9IHN0ZG91dC5pbmRleE9mKFwiTGlzdCBvZiBkZXZpY2VzXCIpO1xuICAgIGlmIChzdGFydGluZ0luZGV4ID09PSAtMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmV4cGVjdGVkIG91dHB1dCB3aGlsZSB0cnlpbmcgdG8gZ2V0IGRldmljZXMuIG91dHB1dCB3YXM6ICR7c3Rkb3V0fWApO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBzbGljaW5nIG91cHV0IHdlIGNhcmUgYWJvdXQuXG4gICAgICBzdGRvdXQgPSBzdGRvdXQuc2xpY2Uoc3RhcnRpbmdJbmRleCk7XG4gICAgICBsZXQgZGV2aWNlcyA9IFtdO1xuICAgICAgZm9yIChsZXQgbGluZSBvZiBzdGRvdXQuc3BsaXQoXCJcXG5cIikpIHtcbiAgICAgICAgaWYgKGxpbmUudHJpbSgpICE9PSBcIlwiICYmXG4gICAgICAgICAgICBsaW5lLmluZGV4T2YoXCJMaXN0IG9mIGRldmljZXNcIikgPT09IC0xICYmXG4gICAgICAgICAgICBsaW5lLmluZGV4T2YoXCJhZGIgc2VydmVyXCIpID09PSAtMSAmJlxuICAgICAgICAgICAgbGluZS5pbmRleE9mKFwiKiBkYWVtb25cIikgPT09IC0xICYmXG4gICAgICAgICAgICBsaW5lLmluZGV4T2YoXCJvZmZsaW5lXCIpID09PSAtMSkge1xuICAgICAgICAgIGxldCBsaW5lSW5mbyA9IGxpbmUuc3BsaXQoXCJcXHRcIik7XG4gICAgICAgICAgLy8gc3RhdGUgaXMgZWl0aGVyIFwiZGV2aWNlXCIgb3IgXCJvZmZsaW5lXCIsIGFmYWljdFxuICAgICAgICAgIGRldmljZXMucHVzaCh7dWRpZDogbGluZUluZm9bMF0sIHN0YXRlOiBsaW5lSW5mb1sxXX0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBsb2cuZGVidWcoYCR7ZGV2aWNlcy5sZW5ndGh9IGRldmljZShzKSBjb25uZWN0ZWRgKTtcbiAgICAgIHJldHVybiBkZXZpY2VzO1xuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIGxvZy5lcnJvckFuZFRocm93KGBFcnJvciB3aGlsZSBnZXR0aW5nIGNvbm5lY3RlZCBkZXZpY2VzLiBPcmlnaW5hbCBlcnJvcjogJHtlLm1lc3NhZ2V9YCk7XG4gIH1cbn07XG5cbnN5c3RlbUNhbGxNZXRob2RzLmdldERldmljZXNXaXRoUmV0cnkgPSBhc3luYyBmdW5jdGlvbiAodGltZW91dE1zID0gMjAwMDApIHtcbiAgbGV0IHN0YXJ0ID0gRGF0ZS5ub3coKTtcbiAgbG9nLmRlYnVnKFwiVHJ5aW5nIHRvIGZpbmQgYSBjb25uZWN0ZWQgYW5kcm9pZCBkZXZpY2VcIik7XG4gIGxldCBnZXREZXZpY2VzID0gYXN5bmMgKCkgPT4ge1xuICAgIGlmICgoRGF0ZS5ub3coKSAtIHN0YXJ0KSA+IHRpbWVvdXRNcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IGZpbmQgYSBjb25uZWN0ZWQgQW5kcm9pZCBkZXZpY2UuXCIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgbGV0IGRldmljZXMgPSBhd2FpdCB0aGlzLmdldENvbm5lY3RlZERldmljZXMoKTtcbiAgICAgIGlmIChkZXZpY2VzLmxlbmd0aCA8IDEpIHtcbiAgICAgICAgbG9nLmRlYnVnKFwiQ291bGQgbm90IGZpbmQgZGV2aWNlcywgcmVzdGFydGluZyBhZGIgc2VydmVyLi4uXCIpO1xuICAgICAgICBhd2FpdCB0aGlzLnJlc3RhcnRBZGIoKTtcbiAgICAgICAgLy8gY29vbCBkb3duXG4gICAgICAgIGF3YWl0IHNsZWVwKDIwMCk7XG4gICAgICAgIHJldHVybiBhd2FpdCBnZXREZXZpY2VzKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGV2aWNlcztcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBsb2cuZGVidWcoXCJDb3VsZCBub3QgZmluZCBkZXZpY2VzLCByZXN0YXJ0aW5nIGFkYiBzZXJ2ZXIuLi5cIik7XG4gICAgICBhd2FpdCB0aGlzLnJlc3RhcnRBZGIoKTtcbiAgICAgIC8vIGNvb2wgZG93blxuICAgICAgYXdhaXQgc2xlZXAoMjAwKTtcbiAgICAgIHJldHVybiBhd2FpdCBnZXREZXZpY2VzKCk7XG4gICAgfVxuICB9O1xuICByZXR1cm4gYXdhaXQgZ2V0RGV2aWNlcygpO1xufTtcblxuc3lzdGVtQ2FsbE1ldGhvZHMucmVzdGFydEFkYiA9IGFzeW5jIGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuc3VwcHJlc3NLaWxsU2VydmVyKSB7XG4gICAgbG9nLmRlYnVnKGBOb3QgcmVzdGFydGluZyBhYmQgc2luY2UgJ3N1cHByZXNzS2lsbFNlcnZlcicgaXMgb25gKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBsb2cuZGVidWcoJ1Jlc3RhcnRpbmcgYWRiJyk7XG4gIHRyeSB7XG4gICAgYXdhaXQgZXhlYyh0aGlzLmV4ZWN1dGFibGUucGF0aCwgWydraWxsLXNlcnZlciddKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGxvZy5lcnJvcihcIkVycm9yIGtpbGxpbmcgQURCIHNlcnZlciwgZ29pbmcgdG8gc2VlIGlmIGl0J3Mgb25saW5lIGFueXdheVwiKTtcbiAgfVxufTtcblxuc3lzdGVtQ2FsbE1ldGhvZHMuYWRiRXhlYyA9IGFzeW5jIGZ1bmN0aW9uIChjbWQsIG9wdHMgPSB7fSkge1xuICBpZiAoIWNtZCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIllvdSBuZWVkIHRvIHBhc3MgaW4gYSBjb21tYW5kIHRvIGFkYkV4ZWMoKVwiKTtcbiAgfVxuICAvLyBzZXR0aW5nIGRlZmF1bHQgdGltZW91dCBmb3IgZWFjaCBjb21tYW5kIHRvIHByZXZlbnQgaW5maW5pdGUgd2FpdC5cbiAgb3B0cy50aW1lb3V0ID0gb3B0cy50aW1lb3V0IHx8IERFRkFVTFRfQURCX0VYRUNfVElNRU9VVDtcbiAgbGV0IGV4ZWNGdW5jID0gYXN5bmMgKCkgPT4ge1xuICAgIGxldCBsaW5rZXJXYXJuaW5nUmUgPSAvXldBUk5JTkc6IGxpbmtlci4rJC9tO1xuICAgIHRyeSB7XG4gICAgICBpZiAoIShjbWQgaW5zdGFuY2VvZiBBcnJheSkpIHtcbiAgICAgICAgY21kID0gW2NtZF07XG4gICAgICB9XG4gICAgICBsZXQgYXJncyA9IHRoaXMuZXhlY3V0YWJsZS5kZWZhdWx0QXJncy5jb25jYXQoY21kKTtcbiAgICAgIGxvZy5kZWJ1ZyhgUnVubmluZyAnJHt0aGlzLmV4ZWN1dGFibGUucGF0aH0nIHdpdGggYXJnczogYCArXG4gICAgICAgICAgICAgICAgYCR7SlNPTi5zdHJpbmdpZnkoYXJncyl9YCk7XG4gICAgICBsZXQge3N0ZG91dH0gPSBhd2FpdCBleGVjKHRoaXMuZXhlY3V0YWJsZS5wYXRoLCBhcmdzLCBvcHRzKTtcbiAgICAgIC8vIHNvbWV0aW1lcyBBREIgcHJpbnRzIG91dCB3ZWlyZCBzdGRvdXQgd2FybmluZ3MgdGhhdCB3ZSBkb24ndCB3YW50XG4gICAgICAvLyB0byBpbmNsdWRlIGluIGFueSBvZiB0aGUgcmVzcG9uc2UgZGF0YSwgc28gbGV0J3Mgc3RyaXAgaXQgb3V0XG4gICAgICBzdGRvdXQgPSBzdGRvdXQucmVwbGFjZShsaW5rZXJXYXJuaW5nUmUsICcnKS50cmltKCk7XG4gICAgICByZXR1cm4gc3Rkb3V0O1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGxldCBwcm90b2NvbEZhdWx0RXJyb3IgPSBuZXcgUmVnRXhwKFwicHJvdG9jb2wgZmF1bHQgXFxcXChubyBzdGF0dXNcXFxcKVwiLCBcImlcIikudGVzdChlKTtcbiAgICAgIGxldCBkZXZpY2VOb3RGb3VuZEVycm9yID0gbmV3IFJlZ0V4cChcImVycm9yOiBkZXZpY2UgKCcuKycgKT9ub3QgZm91bmRcIiwgXCJpXCIpLnRlc3QoZSk7XG4gICAgICBpZiAocHJvdG9jb2xGYXVsdEVycm9yIHx8IGRldmljZU5vdEZvdW5kRXJyb3IpIHtcbiAgICAgICAgbG9nLmluZm8oYEVycm9yIHNlbmRpbmcgY29tbWFuZCwgcmVjb25uZWN0aW5nIGRldmljZSBhbmQgcmV0cnlpbmc6ICR7Y21kfWApO1xuICAgICAgICBhd2FpdCBzbGVlcCgxMDAwKTtcbiAgICAgICAgYXdhaXQgdGhpcy5nZXREZXZpY2VzV2l0aFJldHJ5KCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChlLnN0ZG91dCkge1xuICAgICAgICBsZXQgc3Rkb3V0ID0gZS5zdGRvdXQ7XG4gICAgICAgIHN0ZG91dCA9IHN0ZG91dC5yZXBsYWNlKGxpbmtlcldhcm5pbmdSZSwgJycpLnRyaW0oKTtcbiAgICAgICAgcmV0dXJuIHN0ZG91dDtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBFcnJvcihgRXJyb3IgZXhlY3V0aW5nIGFkYkV4ZWMuIE9yaWdpbmFsIGVycm9yOiAnJHtlLm1lc3NhZ2V9JzsgYCArXG4gICAgICAgICAgICAgICAgICAgICAgICBgU3RkZXJyOiAnJHsoZS5zdGRlcnIgfHwgJycpLnRyaW0oKX0nOyBDb2RlOiAnJHtlLmNvZGV9J2ApO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIGF3YWl0IHJldHJ5KDIsIGV4ZWNGdW5jKTtcbn07XG5cbnN5c3RlbUNhbGxNZXRob2RzLnNoZWxsID0gYXN5bmMgZnVuY3Rpb24gKGNtZCwgb3B0cyA9IHt9KSB7XG4gIGlmICghYXdhaXQgdGhpcy5pc0RldmljZUNvbm5lY3RlZCgpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBObyBkZXZpY2UgY29ubmVjdGVkLCBjYW5ub3QgcnVuIGFkYiBzaGVsbCBjb21tYW5kICcke2NtZC5qb2luKCcgJyl9J2ApO1xuICB9XG4gIGxldCBleGVjQ21kID0gWydzaGVsbCddO1xuICBpZiAoY21kIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICBleGVjQ21kID0gZXhlY0NtZC5jb25jYXQoY21kKTtcbiAgfSBlbHNlIHtcbiAgICBleGVjQ21kLnB1c2goY21kKTtcbiAgfVxuICByZXR1cm4gYXdhaXQgdGhpcy5hZGJFeGVjKGV4ZWNDbWQsIG9wdHMpO1xufTtcblxuc3lzdGVtQ2FsbE1ldGhvZHMuY3JlYXRlU3ViUHJvY2VzcyA9IGZ1bmN0aW9uIChhcmdzID0gW10pIHtcbiAgLy8gYWRkIHRoZSBkZWZhdWx0IGFyZ3VtZW50c1xuICBhcmdzID0gdGhpcy5leGVjdXRhYmxlLmRlZmF1bHRBcmdzLmNvbmNhdChhcmdzKTtcbiAgbG9nLmRlYnVnKGBDcmVhdGluZyBBREIgc3VicHJvY2VzcyB3aXRoIGFyZ3M6ICR7SlNPTi5zdHJpbmdpZnkoYXJncyl9YCk7XG4gIHJldHVybiBuZXcgU3ViUHJvY2Vzcyh0aGlzLmdldEFkYlBhdGgoKSwgYXJncyk7XG59O1xuXG4vLyBUT0RPIGNhbiBwcm9iYWJseSBkZXByZWNhdGUgdGhpcyBub3cgdGhhdCB0aGUgbG9naWMgaXMganVzdCB0byByZWFkXG4vLyB0aGlzLmFkYlBvcnRcbnN5c3RlbUNhbGxNZXRob2RzLmdldEFkYlNlcnZlclBvcnQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmFkYlBvcnQ7XG59O1xuXG5zeXN0ZW1DYWxsTWV0aG9kcy5nZXRFbXVsYXRvclBvcnQgPSBhc3luYyBmdW5jdGlvbiAoKSB7XG4gIGxvZy5kZWJ1ZyhcIkdldHRpbmcgcnVubmluZyBlbXVsYXRvciBwb3J0XCIpO1xuICBpZiAodGhpcy5lbXVsYXRvclBvcnQgIT09IG51bGwpIHtcbiAgICByZXR1cm4gdGhpcy5lbXVsYXRvclBvcnQ7XG4gIH1cbiAgdHJ5IHtcbiAgICBsZXQgZGV2aWNlcyA9IGF3YWl0IHRoaXMuZ2V0Q29ubmVjdGVkRGV2aWNlcygpO1xuICAgIGxldCBwb3J0ID0gdGhpcy5nZXRQb3J0RnJvbUVtdWxhdG9yU3RyaW5nKGRldmljZXNbMF0udWRpZCk7XG4gICAgaWYgKHBvcnQpIHtcbiAgICAgIHJldHVybiBwb3J0O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEVtdWxhdG9yIHBvcnQgbm90IGZvdW5kYCk7XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgbG9nLmVycm9yQW5kVGhyb3coYE5vIGRldmljZXMgY29ubmVjdGVkLiBPcmlnaW5hbCBlcnJvcjogJHtlLm1lc3NhZ2V9YCk7XG4gIH1cbn07XG5cbnN5c3RlbUNhbGxNZXRob2RzLmdldFBvcnRGcm9tRW11bGF0b3JTdHJpbmcgPSBmdW5jdGlvbiAoZW1TdHIpIHtcbiAgbGV0IHBvcnRQYXR0ZXJuID0gL2VtdWxhdG9yLShcXGQrKS87XG4gIGlmIChwb3J0UGF0dGVybi50ZXN0KGVtU3RyKSkge1xuICAgIHJldHVybiBwYXJzZUludChwb3J0UGF0dGVybi5leGVjKGVtU3RyKVsxXSwgMTApO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbnN5c3RlbUNhbGxNZXRob2RzLmdldENvbm5lY3RlZEVtdWxhdG9ycyA9IGFzeW5jIGZ1bmN0aW9uICgpIHtcbiAgdHJ5IHtcbiAgICBsb2cuZGVidWcoXCJHZXR0aW5nIGNvbm5lY3RlZCBlbXVsYXRvcnNcIik7XG4gICAgbGV0IGRldmljZXMgPSBhd2FpdCB0aGlzLmdldENvbm5lY3RlZERldmljZXMoKTtcbiAgICBsZXQgZW11bGF0b3JzID0gW107XG4gICAgZm9yIChsZXQgZGV2aWNlIG9mIGRldmljZXMpIHtcbiAgICAgIGxldCBwb3J0ID0gdGhpcy5nZXRQb3J0RnJvbUVtdWxhdG9yU3RyaW5nKGRldmljZS51ZGlkKTtcbiAgICAgIGlmIChwb3J0KSB7XG4gICAgICAgIGRldmljZS5wb3J0ID0gcG9ydDtcbiAgICAgICAgZW11bGF0b3JzLnB1c2goZGV2aWNlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgbG9nLmRlYnVnKGAke2VtdWxhdG9ycy5sZW5ndGh9IGVtdWxhdG9yKHMpIGNvbm5lY3RlZGApO1xuICAgIHJldHVybiBlbXVsYXRvcnM7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBsb2cuZXJyb3JBbmRUaHJvdyhgRXJyb3IgZ2V0dGluZyBlbXVsYXRvcnMuIE9yaWdpbmFsIGVycm9yOiAke2UubWVzc2FnZX1gKTtcbiAgfVxufTtcblxuc3lzdGVtQ2FsbE1ldGhvZHMuc2V0RW11bGF0b3JQb3J0ID0gZnVuY3Rpb24gKGVtUG9ydCkge1xuICB0aGlzLmVtdWxhdG9yUG9ydCA9IGVtUG9ydDtcbn07XG5cbnN5c3RlbUNhbGxNZXRob2RzLnNldERldmljZUlkID0gZnVuY3Rpb24gKGRldmljZUlkKSB7XG4gIGxvZy5kZWJ1ZyhgU2V0dGluZyBkZXZpY2UgaWQgdG8gJHtkZXZpY2VJZH1gKTtcbiAgdGhpcy5jdXJEZXZpY2VJZCA9IGRldmljZUlkO1xuICBsZXQgYXJnc0hhc0RldmljZSA9IHRoaXMuZXhlY3V0YWJsZS5kZWZhdWx0QXJncy5pbmRleE9mKCctcycpO1xuICBpZiAoYXJnc0hhc0RldmljZSAhPT0gLTEpIHtcbiAgICAvLyByZW1vdmUgdGhlIG9sZCBkZXZpY2UgaWQgZnJvbSB0aGUgYXJndW1lbnRzXG4gICAgdGhpcy5leGVjdXRhYmxlLmRlZmF1bHRBcmdzLnNwbGljZShhcmdzSGFzRGV2aWNlLCAyKTtcbiAgfVxuICB0aGlzLmV4ZWN1dGFibGUuZGVmYXVsdEFyZ3MucHVzaCgnLXMnLCBkZXZpY2VJZCk7XG59O1xuXG5zeXN0ZW1DYWxsTWV0aG9kcy5zZXREZXZpY2UgPSBmdW5jdGlvbiAoZGV2aWNlT2JqKSB7XG4gIGxldCBkZXZpY2VJZCA9IGRldmljZU9iai51ZGlkO1xuICBsZXQgZW1Qb3J0ID0gdGhpcy5nZXRQb3J0RnJvbUVtdWxhdG9yU3RyaW5nKGRldmljZUlkKTtcbiAgdGhpcy5zZXRFbXVsYXRvclBvcnQoZW1Qb3J0KTtcbiAgdGhpcy5zZXREZXZpY2VJZChkZXZpY2VJZCk7XG59O1xuXG5zeXN0ZW1DYWxsTWV0aG9kcy5nZXRSdW5uaW5nQVZEID0gYXN5bmMgZnVuY3Rpb24gKGF2ZE5hbWUpIHtcbiAgdHJ5IHtcbiAgICBsb2cuZGVidWcoYFRyeWluZyB0byBmaW5kICR7YXZkTmFtZX0gZW11bGF0b3JgKTtcbiAgICBsZXQgZW11bGF0b3JzID0gYXdhaXQgdGhpcy5nZXRDb25uZWN0ZWRFbXVsYXRvcnMoKTtcbiAgICBmb3IgKGxldCBlbXVsYXRvciBvZiBlbXVsYXRvcnMpIHtcbiAgICAgIHRoaXMuc2V0RW11bGF0b3JQb3J0KGVtdWxhdG9yLnBvcnQpO1xuICAgICAgbGV0IHJ1bm5pbmdBVkROYW1lID0gYXdhaXQgdGhpcy5zZW5kVGVsbmV0Q29tbWFuZChcImF2ZCBuYW1lXCIpO1xuICAgICAgaWYgKGF2ZE5hbWUgPT09IHJ1bm5pbmdBVkROYW1lKSB7XG4gICAgICAgIGxvZy5kZWJ1ZyhgRm91bmQgZW11bGF0b3IgJHthdmROYW1lfSBpbiBwb3J0ICR7ZW11bGF0b3IucG9ydH1gKTtcbiAgICAgICAgdGhpcy5zZXREZXZpY2VJZChlbXVsYXRvci51ZGlkKTtcbiAgICAgICAgcmV0dXJuIGVtdWxhdG9yO1xuICAgICAgfVxuICAgIH1cbiAgICBsb2cuZGVidWcoYEVtdWxhdG9yICR7YXZkTmFtZX0gbm90IHJ1bm5pbmdgKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGxvZy5lcnJvckFuZFRocm93KGBFcnJvciBnZXR0aW5nIEFWRC4gT3JpZ2luYWwgZXJyb3I6ICR7ZS5tZXNzYWdlfWApO1xuICB9XG59O1xuXG5zeXN0ZW1DYWxsTWV0aG9kcy5nZXRSdW5uaW5nQVZEV2l0aFJldHJ5ID0gYXN5bmMgZnVuY3Rpb24gKGF2ZE5hbWUsIHRpbWVvdXRNcyA9IDIwMDAwKSB7XG4gIHRyeSB7XG4gICAgbGV0IHN0YXJ0ID0gRGF0ZS5ub3coKTtcbiAgICB3aGlsZSAoKERhdGUubm93KCkgLSBzdGFydCkgPCB0aW1lb3V0TXMpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGxldCBydW5uaW5nQVZEID0gYXdhaXQgdGhpcy5nZXRSdW5uaW5nQVZEKGF2ZE5hbWUucmVwbGFjZSgnQCcsICcnKSk7XG4gICAgICAgIGlmIChydW5uaW5nQVZEKSB7XG4gICAgICAgICAgcmV0dXJuIHJ1bm5pbmdBVkQ7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gRG8gbm90aGluZy5cbiAgICAgICAgbG9nLmluZm8oYENvdWxkbid0IGdldCBydW5uaW5nIEFWRCwgd2lsbCByZXRyeS4gRXJyb3Igd2FzOiAke2UubWVzc2FnZX1gKTtcbiAgICAgIH1cbiAgICAgIC8vIGNvb2wgZG93blxuICAgICAgYXdhaXQgc2xlZXAoMjAwKTtcbiAgICB9XG4gICAgbG9nLmVycm9yQW5kVGhyb3coYENvdWxkIG5vdCBmaW5kICR7YXZkTmFtZX0gZW11bGF0b3IuYCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBsb2cuZXJyb3JBbmRUaHJvdyhgRXJyb3IgZ2V0dGluZyBBVkQgd2l0aCByZXRyeS4gT3JpZ2luYWwgZXJyb3I6ICR7ZS5tZXNzYWdlfWApO1xuICB9XG59O1xuXG5zeXN0ZW1DYWxsTWV0aG9kcy5raWxsQWxsRW11bGF0b3JzID0gYXN5bmMgZnVuY3Rpb24gKCkge1xuICBsZXQgY21kLCBhcmdzO1xuICBpZiAoc3lzdGVtLmlzV2luZG93cygpKSB7XG4gICAgY21kID0gJ1RBU0tLSUxMJztcbiAgICBhcmdzID0gWydUQVNLS0lMTCcsICcvSU0nLCAnZW11bGF0b3IuZXhlJ107XG4gIH0gZWxzZSB7XG4gICAgY21kID0gJy91c3IvYmluL2tpbGxhbGwnO1xuICAgIGFyZ3MgPSBbJy1tJywgJ2VtdWxhdG9yKiddO1xuICB9XG4gIHRyeSB7XG4gICAgYXdhaXQgZXhlYyhjbWQsIGFyZ3MpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgbG9nLmVycm9yQW5kVGhyb3coYEVycm9yIGtpbGxpbmcgZW11bGF0b3JzLiBPcmlnaW5hbCBlcnJvcjogJHtlLm1lc3NhZ2V9YCk7XG4gIH1cbn07XG5cbnN5c3RlbUNhbGxNZXRob2RzLmtpbGxFbXVsYXRvciA9IGFzeW5jIGZ1bmN0aW9uIChhdmROYW1lKSB7XG4gIGxvZy5kZWJ1Zyhga2lsbGluZyBhdmQgJyR7YXZkTmFtZX0nYCk7XG4gIGxldCBkZXZpY2UgPSBhd2FpdCB0aGlzLmdldFJ1bm5pbmdBVkQoYXZkTmFtZSk7XG4gIGlmIChkZXZpY2UpIHtcbiAgICBhd2FpdCB0aGlzLmFkYkV4ZWMoWydlbXUnLCAna2lsbCddKTtcbiAgICBsb2cuaW5mbyhgc3VjY2Vzc2Z1bGx5IGtpbGxlZCBlbXVsYXRvciAnJHthdmROYW1lfSdgKTtcbiAgfSBlbHNlIHtcbiAgICBsb2cuaW5mbyhgbm8gYXZkIHdpdGggbmFtZSAnJHthdmROYW1lfScgcnVubmluZy4gc2tpcHBpbmcga2lsbCBzdGVwLmApO1xuICB9XG59O1xuXG5zeXN0ZW1DYWxsTWV0aG9kcy5sYXVuY2hBVkQgPSBhc3luYyBmdW5jdGlvbiAoYXZkTmFtZSwgYXZkQXJncywgbGFuZ3VhZ2UsIGNvdW50cnksXG4gIGF2ZExhdW5jaFRpbWVvdXQgPSA2MDAwMCwgYXZkUmVhZHlUaW1lb3V0ID0gNjAwMDAsIHJldHJ5VGltZXMgPSAxKSB7XG4gIGxvZy5kZWJ1ZyhgTGF1bmNoaW5nIEVtdWxhdG9yIHdpdGggQVZEICR7YXZkTmFtZX0sIGxhdW5jaFRpbWVvdXRgICtcbiAgICAgICAgICAgIGAke2F2ZExhdW5jaFRpbWVvdXR9IG1zIGFuZCByZWFkeVRpbWVvdXQgJHthdmRSZWFkeVRpbWVvdXR9IG1zYCk7XG4gIGxldCBlbXVsYXRvckJpbmFyeVBhdGggPSBhd2FpdCB0aGlzLmdldFNka0JpbmFyeVBhdGgoXCJlbXVsYXRvclwiKTtcbiAgaWYgKGF2ZE5hbWVbMF0gPT09IFwiQFwiKSB7XG4gICAgYXZkTmFtZSA9IGF2ZE5hbWUuc3Vic3RyKDEpO1xuICB9XG4gIGF3YWl0IHRoaXMuY2hlY2tBdmRFeGlzdChhdmROYW1lKTtcbiAgbGV0IGxhdW5jaEFyZ3MgPSBbXCItYXZkXCIsIGF2ZE5hbWVdO1xuICBpZiAodHlwZW9mIGxhbmd1YWdlID09PSBcInN0cmluZ1wiKSB7XG4gICAgbG9nLmRlYnVnKGBTZXR0aW5nIEFuZHJvaWQgRGV2aWNlIExhbmd1YWdlIHRvICR7bGFuZ3VhZ2V9YCk7XG4gICAgbGF1bmNoQXJncy5wdXNoKFwiLXByb3BcIiwgYHBlcnNpc3Quc3lzLmxhbmd1YWdlPSR7bGFuZ3VhZ2UudG9Mb3dlckNhc2UoKX1gKTtcbiAgfVxuICBpZiAodHlwZW9mIGNvdW50cnkgPT09IFwic3RyaW5nXCIpIHtcbiAgICBsb2cuZGVidWcoYFNldHRpbmcgQW5kcm9pZCBEZXZpY2UgQ291bnRyeSB0byAke2NvdW50cnl9YCk7XG4gICAgbGF1bmNoQXJncy5wdXNoKFwiLXByb3BcIiwgYHBlcnNpc3Quc3lzLmNvdW50cnk9JHtjb3VudHJ5LnRvVXBwZXJDYXNlKCl9YCk7XG4gIH1cbiAgbGV0IGxvY2FsZTtcbiAgaWYgKHR5cGVvZiBsYW5ndWFnZSA9PT0gXCJzdHJpbmdcIiAmJiB0eXBlb2YgY291bnRyeSA9PT0gXCJzdHJpbmdcIikge1xuICAgIGxvY2FsZSA9IGxhbmd1YWdlLnRvTG93ZXJDYXNlKCkgKyBcIi1cIiArIGNvdW50cnkudG9VcHBlckNhc2UoKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgbGFuZ3VhZ2UgPT09IFwic3RyaW5nXCIpIHtcbiAgICBsb2NhbGUgPSBsYW5ndWFnZS50b0xvd2VyQ2FzZSgpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBjb3VudHJ5ID09PSBcInN0cmluZ1wiKSB7XG4gICAgbG9jYWxlID0gY291bnRyeTtcbiAgfVxuICBpZiAodHlwZW9mIGxvY2FsZSA9PT0gXCJzdHJpbmdcIikge1xuICAgIGxvZy5kZWJ1ZyhgU2V0dGluZyBBbmRyb2lkIERldmljZSBMb2NhbGUgdG8gJHtsb2NhbGV9YCk7XG4gICAgbGF1bmNoQXJncy5wdXNoKFwiLXByb3BcIiwgYHBlcnNpc3Quc3lzLmxvY2FsZT0ke2xvY2FsZX1gKTtcbiAgfVxuICBpZiAodHlwZW9mIGF2ZEFyZ3MgPT09IFwic3RyaW5nXCIpIHtcbiAgICBhdmRBcmdzID0gYXZkQXJncy5zcGxpdChcIiBcIik7XG4gICAgbGF1bmNoQXJncyA9IGxhdW5jaEFyZ3MuY29uY2F0KGF2ZEFyZ3MpO1xuICB9XG4gIGxvZy5kZWJ1ZyhgUnVubmluZyAnJHtlbXVsYXRvckJpbmFyeVBhdGh9JyB3aXRoIGFyZ3M6ICR7SlNPTi5zdHJpbmdpZnkobGF1bmNoQXJncyl9YCk7XG4gIGxldCBwcm9jID0gbmV3IFN1YlByb2Nlc3MoZW11bGF0b3JCaW5hcnlQYXRoLCBsYXVuY2hBcmdzKTtcbiAgYXdhaXQgcHJvYy5zdGFydCgwKTtcbiAgcHJvYy5vbignb3V0cHV0JywgKHN0ZG91dCwgc3RkZXJyKSA9PiB7XG4gICAgbG9nLmluZm8oYFtBVkQgT1VUUFVUXSAke3N0ZG91dCB8fCBzdGRlcnJ9YCk7XG4gIH0pO1xuICBhd2FpdCByZXRyeShyZXRyeVRpbWVzLCB0aGlzLmdldFJ1bm5pbmdBVkRXaXRoUmV0cnkuYmluZCh0aGlzKSwgYXZkTmFtZSwgYXZkTGF1bmNoVGltZW91dCk7XG4gIGF3YWl0IHRoaXMud2FpdEZvckVtdWxhdG9yUmVhZHkoYXZkUmVhZHlUaW1lb3V0KTtcbiAgcmV0dXJuIHByb2M7XG59O1xuXG5zeXN0ZW1DYWxsTWV0aG9kcy5jaGVja0F2ZEV4aXN0ID0gYXN5bmMgZnVuY3Rpb24gKGF2ZE5hbWUpIHtcbiAgbGV0IGNtZCwgcmVzdWx0O1xuICB0cnkge1xuICAgIGNtZCA9IGF3YWl0IHRoaXMuZ2V0U2RrQmluYXJ5UGF0aCgnZW11bGF0b3InKTtcbiAgICByZXN1bHQgPSBhd2FpdCBleGVjKGNtZCwgWyctbGlzdC1hdmRzJ10pO1xuICB9IGNhdGNoIChlKSB7XG4gICAgbGV0IHVua25vd25PcHRpb25FcnJvciA9IG5ldyBSZWdFeHAoXCJ1bmtub3duIG9wdGlvbjogLWxpc3QtYXZkc1wiLCBcImlcIikudGVzdChlLnN0ZGVycik7XG4gICAgaWYgKCF1bmtub3duT3B0aW9uRXJyb3IpIHtcbiAgICAgIGxvZy5lcnJvckFuZFRocm93KGBFcnJvciBleGVjdXRpbmcgY2hlY2tBdmRFeGlzdC4gT3JpZ2luYWwgZXJyb3I6ICcke2UubWVzc2FnZX0nOyBgICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGBTdGRlcnI6ICckeyhlLnN0ZGVyciB8fCAnJykudHJpbSgpfSc7IENvZGU6ICcke2UuY29kZX0nYCk7XG5cbiAgICB9XG4gICAgY29uc3Qgc2RrVmVyc2lvbiA9IGF3YWl0IGdldFNka1Rvb2xzVmVyc2lvbigpO1xuICAgIGxldCBiaW5hcnlOYW1lID0gJ2FuZHJvaWQnO1xuICAgIGlmIChzZGtWZXJzaW9uKSB7XG4gICAgICBpZiAoc2RrVmVyc2lvbi5tYWpvciA+PSAyNSkge1xuICAgICAgICBiaW5hcnlOYW1lID0gJ2F2ZG1hbmFnZXInO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsb2cud2FybihgRGVmYXVsdGluZyBiaW5hcnkgbmFtZSB0byAnJHtiaW5hcnlOYW1lfScsIGJlY2F1c2UgU0RLIHZlcnNpb24gY2Fubm90IGJlIHBhcnNlZGApO1xuICAgIH1cbiAgICAvLyBJZiAtbGlzdC1hdmRzIG9wdGlvbiBpcyBub3QgYXZhaWxhYmxlLCB1c2UgYW5kcm9pZCBjb21tYW5kIGFzIGFuIGFsdGVybmF0aXZlXG4gICAgY21kID0gYXdhaXQgdGhpcy5nZXRTZGtCaW5hcnlQYXRoKGJpbmFyeU5hbWUpO1xuICAgIHJlc3VsdCA9IGF3YWl0IGV4ZWMoY21kLCBbJ2xpc3QnLCAnYXZkJywgJy1jJ10pO1xuICB9XG4gIGlmIChyZXN1bHQuc3Rkb3V0LmluZGV4T2YoYXZkTmFtZSkgPT09IC0xKSB7XG4gICAgbGV0IGV4aXN0aW5ncyA9IGAoJHtyZXN1bHQuc3Rkb3V0LnRyaW0oKS5yZXBsYWNlKC9bXFxuXS9nLCAnKSwgKCcpfSlgO1xuICAgIGxvZy5lcnJvckFuZFRocm93KGBBdmQgJyR7YXZkTmFtZX0nIGlzIG5vdCBhdmFpbGFibGUuIHBsZWFzZSBzZWxlY3QgeW91ciBhdmQgbmFtZSBmcm9tIG9uZSBvZiB0aGVzZTogJyR7ZXhpc3RpbmdzfSdgKTtcbiAgfVxufTtcblxuc3lzdGVtQ2FsbE1ldGhvZHMud2FpdEZvckVtdWxhdG9yUmVhZHkgPSBhc3luYyBmdW5jdGlvbiAodGltZW91dE1zID0gMjAwMDApIHtcbiAgbGV0IHN0YXJ0ID0gRGF0ZS5ub3coKTtcbiAgbG9nLmRlYnVnKFwiV2FpdGluZyB1bnRpbCBlbXVsYXRvciBpcyByZWFkeVwiKTtcbiAgd2hpbGUgKChEYXRlLm5vdygpIC0gc3RhcnQpIDwgdGltZW91dE1zKSB7XG4gICAgdHJ5IHtcbiAgICAgIGxldCBzdGRvdXQgPSBhd2FpdCB0aGlzLnNoZWxsKFtcImdldHByb3BcIiwgXCJpbml0LnN2Yy5ib290YW5pbVwiXSk7XG4gICAgICBpZiAoc3Rkb3V0LmluZGV4T2YoJ3N0b3BwZWQnKSA+IC0xKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyBkbyBub3RoaW5nXG4gICAgfVxuICAgIGF3YWl0IHNsZWVwKDMwMDApO1xuICB9XG4gIGxvZy5lcnJvckFuZFRocm93KCdFbXVsYXRvciBub3QgcmVhZHknKTtcbn07XG5cbnN5c3RlbUNhbGxNZXRob2RzLndhaXRGb3JEZXZpY2UgPSBhc3luYyBmdW5jdGlvbiAoYXBwRGV2aWNlUmVhZHlUaW1lb3V0ID0gMzApIHtcbiAgdGhpcy5hcHBEZXZpY2VSZWFkeVRpbWVvdXQgPSBhcHBEZXZpY2VSZWFkeVRpbWVvdXQ7XG4gIGNvbnN0IHJldHJpZXMgPSAzO1xuICBjb25zdCB0aW1lb3V0ID0gcGFyc2VJbnQodGhpcy5hcHBEZXZpY2VSZWFkeVRpbWVvdXQsIDEwKSAvIHJldHJpZXMgKiAxMDAwO1xuICBhd2FpdCByZXRyeShyZXRyaWVzLCBhc3luYyAoKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHRoaXMuYWRiRXhlYygnd2FpdC1mb3ItZGV2aWNlJywge3RpbWVvdXR9KTtcbiAgICAgIGF3YWl0IHRoaXMucGluZygpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGF3YWl0IHRoaXMucmVzdGFydEFkYigpO1xuICAgICAgYXdhaXQgdGhpcy5nZXRDb25uZWN0ZWREZXZpY2VzKCk7XG4gICAgICBsb2cuZXJyb3JBbmRUaHJvdyhgRXJyb3IgaW4gd2FpdGluZyBmb3IgZGV2aWNlLiBPcmlnaW5hbCBlcnJvcjogJyR7ZS5tZXNzYWdlfScuIGAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgIGBSZXRyeWluZyBieSByZXN0YXJ0aW5nIEFEQmApO1xuICAgIH1cbiAgfSk7XG59O1xuXG5zeXN0ZW1DYWxsTWV0aG9kcy5yZWJvb3QgPSBhc3luYyBmdW5jdGlvbiAoKSB7XG4gIHRyeSB7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHRoaXMuc2hlbGwoWydzdG9wJ10pO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgaWYgKGVyci5tZXNzYWdlLmluZGV4T2YoJ211c3QgYmUgcm9vdCcpID09PSAtMSkge1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9XG4gICAgICAvLyB0aGlzIGRldmljZSBuZWVkcyBhZGIgdG8gYmUgcnVubmluZyBhcyByb290IHRvIHN0b3AuXG4gICAgICAvLyBzbyB0cnkgdG8gcmVzdGFydCB0aGUgZGFlbW9uXG4gICAgICBsb2cuZGVidWcoJ0RldmljZSByZXF1aXJlcyBhZGIgdG8gYmUgcnVubmluZyBhcyByb290IGluIG9yZGVyIHRvIHJlYm9vdC4gUmVzdGFydGluZyBkYWVtb24nKTtcbiAgICAgIGF3YWl0IGV4ZWModGhpcy5leGVjdXRhYmxlLnBhdGgsIFsncm9vdCddKTtcbiAgICAgIGF3YWl0IHRoaXMuc2hlbGwoWydzdG9wJ10pO1xuICAgIH1cbiAgICBhd2FpdCBCLmRlbGF5KDIwMDApOyAvLyBsZXQgdGhlIGVtdSBmaW5pc2ggc3RvcHBpbmc7XG4gICAgYXdhaXQgdGhpcy5zZXREZXZpY2VQcm9wZXJ0eSgnc3lzLmJvb3RfY29tcGxldGVkJywgMCk7XG4gICAgYXdhaXQgdGhpcy5zaGVsbChbJ3N0YXJ0J10pO1xuICAgIGF3YWl0IHJldHJ5SW50ZXJ2YWwoOTAsIDEwMDAsIGFzeW5jICgpID0+IHtcbiAgICAgIGxldCBib290ZWQgPSBhd2FpdCB0aGlzLmdldERldmljZVByb3BlcnR5KCdzeXMuYm9vdF9jb21wbGV0ZWQnKTtcbiAgICAgIGlmIChib290ZWQgPT09ICcxJykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyB3ZSBkb24ndCB3YW50IHRoZSBzdGFjayB0cmFjZSwgc28gbm8gbG9nLmVycm9yQW5kVGhyb3dcbiAgICAgICAgbGV0IG1zZyA9ICdXYWl0aW5nIGZvciByZWJvb3QuIFRoaXMgdGFrZXMgdGltZSc7XG4gICAgICAgIGxvZy5kZWJ1Zyhtc2cpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSBmaW5hbGx5IHtcbiAgICBhd2FpdCBleGVjKHRoaXMuZXhlY3V0YWJsZS5wYXRoLCBbJ3Vucm9vdCddKTtcbiAgfVxufTtcblxuc3lzdGVtQ2FsbE1ldGhvZHMuZmlsZUV4aXN0cyA9IGFzeW5jIGZ1bmN0aW9uIChyZW1vdGVQYXRoKSB7XG4gIGxldCBmaWxlcyA9IGF3YWl0IHRoaXMubHMocmVtb3RlUGF0aCk7XG4gIHJldHVybiBmaWxlcy5sZW5ndGggPiAwO1xufTtcblxuc3lzdGVtQ2FsbE1ldGhvZHMubHMgPSBhc3luYyBmdW5jdGlvbiAocmVtb3RlUGF0aCkge1xuICB0cnkge1xuICAgIGxldCBzdGRvdXQgPSBhd2FpdCB0aGlzLnNoZWxsKFsnbHMnLCByZW1vdGVQYXRoXSk7XG4gICAgbGV0IGxpbmVzID0gc3Rkb3V0LnNwbGl0KFwiXFxuXCIpO1xuICAgIHJldHVybiBsaW5lcy5tYXAoKGwpID0+IGwudHJpbSgpKVxuICAgICAgICAgICAgICAgIC5maWx0ZXIoQm9vbGVhbilcbiAgICAgICAgICAgICAgICAuZmlsdGVyKChsKSA9PiBsLmluZGV4T2YoXCJObyBzdWNoIGZpbGVcIikgPT09IC0xKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgaWYgKGVyci5tZXNzYWdlLmluZGV4T2YoJ05vIHN1Y2ggZmlsZSBvciBkaXJlY3RvcnknKSA9PT0gLTEpIHtcbiAgICAgIHRocm93IGVycjtcbiAgICB9XG4gICAgcmV0dXJuIFtdO1xuICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBzeXN0ZW1DYWxsTWV0aG9kcztcbiJdLCJzb3VyY2VSb290IjoiLi4vLi4vLi4ifQ==
